{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview \u00b6 Vector is a Kotlin Coroutines based MVI Architecture library for Android. It is inspired from MvRx and Roxie , but unlike them it is built completely using Kotlin Coroutines instead of RxJava. As such, it internally only uses Coroutine primitives, and has extensive support for Suspending functions. Vector works well with Android Architecture Components. It is 100% Kotlin, and is intended for use with Kotlin only. Installation Instructions \u00b6 Add the Jitpack repository to your top level build.gradle file. allprojects { repositories { ... maven { url 'https://jitpack.io' } } } And then add the following dependency in your module's build.gradle file: dependencies { implementation \"com.github.haroldadmin:Vector:(latest-version)\" } R8/Proguard Config \u00b6 The library ships with consumer proguard rules, so no additional configuration should be required. License \u00b6 Copyright 2019 Vector Contributors Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Overview"},{"location":"#overview","text":"Vector is a Kotlin Coroutines based MVI Architecture library for Android. It is inspired from MvRx and Roxie , but unlike them it is built completely using Kotlin Coroutines instead of RxJava. As such, it internally only uses Coroutine primitives, and has extensive support for Suspending functions. Vector works well with Android Architecture Components. It is 100% Kotlin, and is intended for use with Kotlin only.","title":"Overview"},{"location":"#installation-instructions","text":"Add the Jitpack repository to your top level build.gradle file. allprojects { repositories { ... maven { url 'https://jitpack.io' } } } And then add the following dependency in your module's build.gradle file: dependencies { implementation \"com.github.haroldadmin:Vector:(latest-version)\" }","title":"Installation Instructions"},{"location":"#r8proguard-config","text":"The library ships with consumer proguard rules, so no additional configuration should be required.","title":"R8/Proguard Config"},{"location":"#license","text":"Copyright 2019 Vector Contributors Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"introduction/","text":"Introduction \u00b6 Vector helps you build an app based on the Model-View-Intent architecture pattern. Hannes Dorfmann has written an excellent series of blog posts about this pattern, the links to which you can find at the bottom of this page. I won't try to explain in detail what MVI is, much more qualified people have already done so in great detail. This page contains only a small summary. Note Vector uses Experimental Coroutine API's under the hood, so the design of this library could change drastically as and when the design of Coroutines in the language evolves. MVI \u00b6 An app is essentially a collection of screens with which the user interacts. Each screen is called a View . Almost all screens in an app need some data to generate views to display on the screen. This data is called the Model . Views render UI elements to the screen based on the information contained in the Model. The user interacts with these UI elements, possibly triggering some 'actions' that mutate the UI state. These actions are called Intents . Intents are dispatched to a 'controller' of the screen, which mutates the Model based on the triggered action and produces a new one. The UI reacts to the updated model and re-renders itself based on the new data. Why use a library for this? \u00b6 In the version of MVI that I just described, we can see a clear pattern followed by each screen of the app. Setting up MVI this way requires you to create a lot of boilerplate code to get things up and running. Even then, things are difficult to get right in the first try. You have to make sure that mutations to the data model are processed sequentially even though the sources of actions may be asynchronous. Vector helps you with all these things. It takes care of most of the boilerplate, state mutations are always processed sequentially even though the sources of mutations be asynchronous, and it encourages clean architectural practices. Why use Vector for this? \u00b6 Granted, there are quite a lot of excellent MVI architecture libraries available for Android. Here are some of them, I encourage you to check them out: MvRx MvRx by AirBnb is an excellent library, and Vector draws a lot of its design from it. However, MvRx is heavily reliant on RxJava and has less than stellar support for Kotlin's suspending functions. It also tries to do a lot more than just simple state management, and is very close to being a framework rather than a library. Vector, on the other hand, is small and lightweight. It is also built completely using Kotlin Coroutines and therefore offers excellent support for suspending functions. It tries not to do a whole lot more than managing state, and therefore lets you freely choose how you want to design the rest of your app. Roxie Roxie is a small and lightweight library, just like Vector, but it also does not have great support for suspending functions. It also treats actions as a very well defined entity, something which Vector does not. Roxie recommends using a Kotlin Sealed Class to represent all possible actions that can be performed on a screen. It also recommends a very different pattern of reducers than what Vector does. Thus, while Roxie itself is quite small, the boilerplate that comes with it is not. Mobius Mobius is another popular MVI framework by Spotify, and is also recommended by a lot of developers in the community. Vector borrows from the design of both MvRx and Roxie, and I would like to sincerely thank the developers of both of them. Vector's approach to MVI \u00b6 Vector recommends using a Kotlin Data Class to represent the UI Model. Your model class should implement the VectorState interface. Intents are regular lambdas in Vector. State reducers are of the type S.() -> S , where S is a model class implementing the VectorState interface. Vector does not have an opinion regarding what Views should be in your app. We supply a convenient VectorFragment abstract class in the library, but it is not necessary to use it. While the sample app in the repository uses Fragments , you are free to choose whatever you like. The current state is exposed to the View through a Kotlin Flow object, so it helps if your View class is a CoroutineScope with. Building Blocks \u00b6 Vector State Vector Fragment Vector ViewModel Further Reading \u00b6 Hannes Dorfmann blog series on MVI MvRx: Android on Autopilot","title":"Introduction"},{"location":"introduction/#introduction","text":"Vector helps you build an app based on the Model-View-Intent architecture pattern. Hannes Dorfmann has written an excellent series of blog posts about this pattern, the links to which you can find at the bottom of this page. I won't try to explain in detail what MVI is, much more qualified people have already done so in great detail. This page contains only a small summary. Note Vector uses Experimental Coroutine API's under the hood, so the design of this library could change drastically as and when the design of Coroutines in the language evolves.","title":"Introduction"},{"location":"introduction/#mvi","text":"An app is essentially a collection of screens with which the user interacts. Each screen is called a View . Almost all screens in an app need some data to generate views to display on the screen. This data is called the Model . Views render UI elements to the screen based on the information contained in the Model. The user interacts with these UI elements, possibly triggering some 'actions' that mutate the UI state. These actions are called Intents . Intents are dispatched to a 'controller' of the screen, which mutates the Model based on the triggered action and produces a new one. The UI reacts to the updated model and re-renders itself based on the new data.","title":"MVI"},{"location":"introduction/#why-use-a-library-for-this","text":"In the version of MVI that I just described, we can see a clear pattern followed by each screen of the app. Setting up MVI this way requires you to create a lot of boilerplate code to get things up and running. Even then, things are difficult to get right in the first try. You have to make sure that mutations to the data model are processed sequentially even though the sources of actions may be asynchronous. Vector helps you with all these things. It takes care of most of the boilerplate, state mutations are always processed sequentially even though the sources of mutations be asynchronous, and it encourages clean architectural practices.","title":"Why use a library for this?"},{"location":"introduction/#why-use-vector-for-this","text":"Granted, there are quite a lot of excellent MVI architecture libraries available for Android. Here are some of them, I encourage you to check them out: MvRx MvRx by AirBnb is an excellent library, and Vector draws a lot of its design from it. However, MvRx is heavily reliant on RxJava and has less than stellar support for Kotlin's suspending functions. It also tries to do a lot more than just simple state management, and is very close to being a framework rather than a library. Vector, on the other hand, is small and lightweight. It is also built completely using Kotlin Coroutines and therefore offers excellent support for suspending functions. It tries not to do a whole lot more than managing state, and therefore lets you freely choose how you want to design the rest of your app. Roxie Roxie is a small and lightweight library, just like Vector, but it also does not have great support for suspending functions. It also treats actions as a very well defined entity, something which Vector does not. Roxie recommends using a Kotlin Sealed Class to represent all possible actions that can be performed on a screen. It also recommends a very different pattern of reducers than what Vector does. Thus, while Roxie itself is quite small, the boilerplate that comes with it is not. Mobius Mobius is another popular MVI framework by Spotify, and is also recommended by a lot of developers in the community. Vector borrows from the design of both MvRx and Roxie, and I would like to sincerely thank the developers of both of them.","title":"Why use Vector for this?"},{"location":"introduction/#vectors-approach-to-mvi","text":"Vector recommends using a Kotlin Data Class to represent the UI Model. Your model class should implement the VectorState interface. Intents are regular lambdas in Vector. State reducers are of the type S.() -> S , where S is a model class implementing the VectorState interface. Vector does not have an opinion regarding what Views should be in your app. We supply a convenient VectorFragment abstract class in the library, but it is not necessary to use it. While the sample app in the repository uses Fragments , you are free to choose whatever you like. The current state is exposed to the View through a Kotlin Flow object, so it helps if your View class is a CoroutineScope with.","title":"Vector's approach to MVI"},{"location":"introduction/#building-blocks","text":"Vector State Vector Fragment Vector ViewModel","title":"Building Blocks"},{"location":"introduction/#further-reading","text":"Hannes Dorfmann blog series on MVI MvRx: Android on Autopilot","title":"Further Reading"},{"location":"api/vector/","text":"vector Packages \u00b6 Name Summary com.haroldadmin.vector com.haroldadmin.vector.loggers com.haroldadmin.vector.state Index \u00b6 All Types","title":"API Reference"},{"location":"api/vector/#packages","text":"Name Summary com.haroldadmin.vector com.haroldadmin.vector.loggers com.haroldadmin.vector.state","title":"Packages"},{"location":"api/vector/#index","text":"All Types","title":"Index"},{"location":"api/vector/alltypes/","text":"All Types \u00b6 Name Summary com.haroldadmin.vector.ActivityViewModelOwner A ViewModelOwner wrapping an Activity androidx.activity.ComponentActivity (extensions in package com.haroldadmin.vector) androidx.fragment.app.Fragment (extensions in package com.haroldadmin.vector) com.haroldadmin.vector.FragmentViewModelOwner A ViewModelOwner which wraps the parent fragment of a ViewModel com.haroldadmin.vector.loggers.Logger Used to write debug logs. com.haroldadmin.vector.SavedStateVectorViewModel A Subclass of VectorViewModel that has access to a SavedStateHandle to easily persist state properties in case of process death com.haroldadmin.vector.state.StateHolder Holds the current state value and provides access to it. A ConflatedBroadcastChannel is used to hold the current state value. clear should be called when this state holder is no longer in use. com.haroldadmin.vector.state.StateProcessor An entity that manages any Action on state. com.haroldadmin.vector.state.StateStore A class which can hold current state as well as handle actions to be performed on it. com.haroldadmin.vector.Vector Singleton object to configure the library com.haroldadmin.vector.VectorFragment A Fragment which has a convenient fragmentScope property to easily launch coroutines in it. com.haroldadmin.vector.vectorLazy A lazy delegate class, which takes in an initializer to initialize its underlying property. Implements the double-checked locking algorithm. com.haroldadmin.vector.VectorState A state object contains all the necessary information to render the view. com.haroldadmin.vector.VectorViewModel The Base ViewModel class your ViewModel should inherit from com.haroldadmin.vector.VectorViewModelFactory A Factory meant to be implemented using the Companion object of a VectorViewModel to provide ways to create the initial state, as well as the creation of the ViewModel itself. com.haroldadmin.vector.VectorViewModelProvider A class which is responsible for creating ViewModel instances. com.haroldadmin.vector.ViewModelOwner ViewModelOwner wraps the owner of a VectorViewModel .","title":"Home"},{"location":"api/vector/alltypes/#all-types","text":"Name Summary com.haroldadmin.vector.ActivityViewModelOwner A ViewModelOwner wrapping an Activity androidx.activity.ComponentActivity (extensions in package com.haroldadmin.vector) androidx.fragment.app.Fragment (extensions in package com.haroldadmin.vector) com.haroldadmin.vector.FragmentViewModelOwner A ViewModelOwner which wraps the parent fragment of a ViewModel com.haroldadmin.vector.loggers.Logger Used to write debug logs. com.haroldadmin.vector.SavedStateVectorViewModel A Subclass of VectorViewModel that has access to a SavedStateHandle to easily persist state properties in case of process death com.haroldadmin.vector.state.StateHolder Holds the current state value and provides access to it. A ConflatedBroadcastChannel is used to hold the current state value. clear should be called when this state holder is no longer in use. com.haroldadmin.vector.state.StateProcessor An entity that manages any Action on state. com.haroldadmin.vector.state.StateStore A class which can hold current state as well as handle actions to be performed on it. com.haroldadmin.vector.Vector Singleton object to configure the library com.haroldadmin.vector.VectorFragment A Fragment which has a convenient fragmentScope property to easily launch coroutines in it. com.haroldadmin.vector.vectorLazy A lazy delegate class, which takes in an initializer to initialize its underlying property. Implements the double-checked locking algorithm. com.haroldadmin.vector.VectorState A state object contains all the necessary information to render the view. com.haroldadmin.vector.VectorViewModel The Base ViewModel class your ViewModel should inherit from com.haroldadmin.vector.VectorViewModelFactory A Factory meant to be implemented using the Companion object of a VectorViewModel to provide ways to create the initial state, as well as the creation of the ViewModel itself. com.haroldadmin.vector.VectorViewModelProvider A class which is responsible for creating ViewModel instances. com.haroldadmin.vector.ViewModelOwner ViewModelOwner wraps the owner of a VectorViewModel .","title":"All Types"},{"location":"api/vector/com.haroldadmin.vector/","text":"vector / com.haroldadmin.vector Package com.haroldadmin.vector \u00b6 Types \u00b6 Name Summary ActivityViewModelOwner class ActivityViewModelOwner : ViewModelOwner A ViewModelOwner wrapping an Activity FragmentViewModelOwner class FragmentViewModelOwner : ViewModelOwner A ViewModelOwner which wraps the parent fragment of a ViewModel SavedStateVectorViewModel abstract class SavedStateVectorViewModel<S : VectorState > : VectorViewModel < S > A Subclass of VectorViewModel that has access to a SavedStateHandle to easily persist state properties in case of process death Vector object Vector Singleton object to configure the library VectorFragment abstract class VectorFragment : Fragment A Fragment which has a convenient fragmentScope property to easily launch coroutines in it. vectorLazy class vectorLazy<out T> : Lazy < T > A lazy delegate class, which takes in an initializer to initialize its underlying property. Implements the double-checked locking algorithm. VectorState interface VectorState A state object contains all the necessary information to render the view. VectorViewModel abstract class VectorViewModel<S : VectorState > : ViewModel The Base ViewModel class your ViewModel should inherit from VectorViewModelFactory interface VectorViewModelFactory<VM : VectorViewModel < S >, S : VectorState > A Factory meant to be implemented using the Companion object of a VectorViewModel to provide ways to create the initial state, as well as the creation of the ViewModel itself. VectorViewModelProvider object VectorViewModelProvider A class which is responsible for creating ViewModel instances. ViewModelOwner sealed class ViewModelOwner ViewModelOwner wraps the owner of a VectorViewModel . Extensions for External Classes \u00b6 Name Summary androidx.activity.ComponentActivity androidx.fragment.app.Fragment Functions \u00b6 Name Summary context fun ViewModelOwner .context(): Context Get access to Context from a ViewModelOwner . withState fun <S : VectorState > withState(viewModel: VectorViewModel < S >, block: ( S ) -> Unit ): Unit A convenience function to access current state and execute an action on it.","title":"Home"},{"location":"api/vector/com.haroldadmin.vector/#package-comharoldadminvector","text":"","title":"Package com.haroldadmin.vector"},{"location":"api/vector/com.haroldadmin.vector/#types","text":"Name Summary ActivityViewModelOwner class ActivityViewModelOwner : ViewModelOwner A ViewModelOwner wrapping an Activity FragmentViewModelOwner class FragmentViewModelOwner : ViewModelOwner A ViewModelOwner which wraps the parent fragment of a ViewModel SavedStateVectorViewModel abstract class SavedStateVectorViewModel<S : VectorState > : VectorViewModel < S > A Subclass of VectorViewModel that has access to a SavedStateHandle to easily persist state properties in case of process death Vector object Vector Singleton object to configure the library VectorFragment abstract class VectorFragment : Fragment A Fragment which has a convenient fragmentScope property to easily launch coroutines in it. vectorLazy class vectorLazy<out T> : Lazy < T > A lazy delegate class, which takes in an initializer to initialize its underlying property. Implements the double-checked locking algorithm. VectorState interface VectorState A state object contains all the necessary information to render the view. VectorViewModel abstract class VectorViewModel<S : VectorState > : ViewModel The Base ViewModel class your ViewModel should inherit from VectorViewModelFactory interface VectorViewModelFactory<VM : VectorViewModel < S >, S : VectorState > A Factory meant to be implemented using the Companion object of a VectorViewModel to provide ways to create the initial state, as well as the creation of the ViewModel itself. VectorViewModelProvider object VectorViewModelProvider A class which is responsible for creating ViewModel instances. ViewModelOwner sealed class ViewModelOwner ViewModelOwner wraps the owner of a VectorViewModel .","title":"Types"},{"location":"api/vector/com.haroldadmin.vector/#extensions-for-external-classes","text":"Name Summary androidx.activity.ComponentActivity androidx.fragment.app.Fragment","title":"Extensions for External Classes"},{"location":"api/vector/com.haroldadmin.vector/#functions","text":"Name Summary context fun ViewModelOwner .context(): Context Get access to Context from a ViewModelOwner . withState fun <S : VectorState > withState(viewModel: VectorViewModel < S >, block: ( S ) -> Unit ): Unit A convenience function to access current state and execute an action on it.","title":"Functions"},{"location":"api/vector/com.haroldadmin.vector/-vector-state/","text":"vector / com.haroldadmin.vector / VectorState VectorState \u00b6 interface VectorState A state object contains all the necessary information to render the view. Can be used with Kotlin data classes to allow for easy mutation using the generated copy function. Example: data class NotesListState ( val notes : List < Note > = listOf () ): VectorState","title":" vector state"},{"location":"api/vector/com.haroldadmin.vector/-vector-state/#vectorstate","text":"interface VectorState A state object contains all the necessary information to render the view. Can be used with Kotlin data classes to allow for easy mutation using the generated copy function. Example: data class NotesListState ( val notes : List < Note > = listOf () ): VectorState","title":"VectorState"},{"location":"api/vector/com.haroldadmin.vector/-view-model-owner/","text":"vector / com.haroldadmin.vector / ViewModelOwner ViewModelOwner \u00b6 sealed class ViewModelOwner ViewModelOwner wraps the owner of a VectorViewModel . Use it to get access to your object graph, arguments and saved instance state during the creation of the ViewModel. DO NOT STORE A REFERENCE TO THIS IN YOUR VIEWMODEL Extension Functions \u00b6 Name Summary context fun ViewModelOwner .context(): Context Get access to Context from a ViewModelOwner . Inheritors \u00b6 Name Summary ActivityViewModelOwner class ActivityViewModelOwner : ViewModelOwner A ViewModelOwner wrapping an Activity FragmentViewModelOwner class FragmentViewModelOwner : ViewModelOwner A ViewModelOwner which wraps the parent fragment of a ViewModel","title":" view model owner"},{"location":"api/vector/com.haroldadmin.vector/-view-model-owner/#viewmodelowner","text":"sealed class ViewModelOwner ViewModelOwner wraps the owner of a VectorViewModel . Use it to get access to your object graph, arguments and saved instance state during the creation of the ViewModel. DO NOT STORE A REFERENCE TO THIS IN YOUR VIEWMODEL","title":"ViewModelOwner"},{"location":"api/vector/com.haroldadmin.vector/-view-model-owner/#extension-functions","text":"Name Summary context fun ViewModelOwner .context(): Context Get access to Context from a ViewModelOwner .","title":"Extension Functions"},{"location":"api/vector/com.haroldadmin.vector/-view-model-owner/#inheritors","text":"Name Summary ActivityViewModelOwner class ActivityViewModelOwner : ViewModelOwner A ViewModelOwner wrapping an Activity FragmentViewModelOwner class FragmentViewModelOwner : ViewModelOwner A ViewModelOwner which wraps the parent fragment of a ViewModel","title":"Inheritors"},{"location":"api/vector/com.haroldadmin.vector/context/","text":"vector / com.haroldadmin.vector / context context \u00b6 fun ViewModelOwner .context(): Context Get access to Context from a ViewModelOwner . When this is an ActivityViewModelOwner , it returns the wrapped activity itself. When this is a FragmentViewModelOwner , returns the context from the wrapped fragment.","title":"Context"},{"location":"api/vector/com.haroldadmin.vector/context/#context","text":"fun ViewModelOwner .context(): Context Get access to Context from a ViewModelOwner . When this is an ActivityViewModelOwner , it returns the wrapped activity itself. When this is a FragmentViewModelOwner , returns the context from the wrapped fragment.","title":"context"},{"location":"api/vector/com.haroldadmin.vector/with-state/","text":"vector / com.haroldadmin.vector / withState withState \u00b6 inline fun <S : VectorState > withState(viewModel: VectorViewModel < S >, crossinline block: ( S ) -> Unit ): Unit A convenience function to access current state and execute an action on it. Parameters \u00b6 S - The type of the current state block - The action to be performed using the current state Example: class MyViewModel(): VectorViewModel() class MyFragment(): VectorFragment { onViewCreated(...) { withState(viewModel) { state -> if (state.isPremiumUser) { premiumFeature.enable() } } } } Note: The state provided to the block is not guaranteed to be the latest state, because there might be other state mutation blocks in the State Store's queue Warning: This WILL cause your app to crash if you create your ViewModels without initial state and fail to provide it later, before calling this function.","title":"With state"},{"location":"api/vector/com.haroldadmin.vector/with-state/#withstate","text":"inline fun <S : VectorState > withState(viewModel: VectorViewModel < S >, crossinline block: ( S ) -> Unit ): Unit A convenience function to access current state and execute an action on it.","title":"withState"},{"location":"api/vector/com.haroldadmin.vector/with-state/#parameters","text":"S - The type of the current state block - The action to be performed using the current state Example: class MyViewModel(): VectorViewModel() class MyFragment(): VectorFragment { onViewCreated(...) { withState(viewModel) { state -> if (state.isPremiumUser) { premiumFeature.enable() } } } } Note: The state provided to the block is not guaranteed to be the latest state, because there might be other state mutation blocks in the State Store's queue Warning: This WILL cause your app to crash if you create your ViewModels without initial state and fail to provide it later, before calling this function.","title":"Parameters"},{"location":"api/vector/com.haroldadmin.vector/-activity-view-model-owner/","text":"vector / com.haroldadmin.vector / ActivityViewModelOwner ActivityViewModelOwner \u00b6 class ActivityViewModelOwner : ViewModelOwner A ViewModelOwner wrapping an Activity Constructors \u00b6 Name Summary <init> ActivityViewModelOwner(activity: ComponentActivity ) Creates a ViewModelOwner wrapping the given Activity Properties \u00b6 Name Summary activity val activity: ComponentActivity The underlying activity of this ViewModelOwner Functions \u00b6 Name Summary activity fun <A : FragmentActivity > activity(): A Get a type-casted version of the wrapped activity Extension Functions \u00b6 Name Summary context fun ViewModelOwner .context(): Context Get access to Context from a ViewModelOwner .","title":"Home"},{"location":"api/vector/com.haroldadmin.vector/-activity-view-model-owner/#activityviewmodelowner","text":"class ActivityViewModelOwner : ViewModelOwner A ViewModelOwner wrapping an Activity","title":"ActivityViewModelOwner"},{"location":"api/vector/com.haroldadmin.vector/-activity-view-model-owner/#constructors","text":"Name Summary <init> ActivityViewModelOwner(activity: ComponentActivity ) Creates a ViewModelOwner wrapping the given Activity","title":"Constructors"},{"location":"api/vector/com.haroldadmin.vector/-activity-view-model-owner/#properties","text":"Name Summary activity val activity: ComponentActivity The underlying activity of this ViewModelOwner","title":"Properties"},{"location":"api/vector/com.haroldadmin.vector/-activity-view-model-owner/#functions","text":"Name Summary activity fun <A : FragmentActivity > activity(): A Get a type-casted version of the wrapped activity","title":"Functions"},{"location":"api/vector/com.haroldadmin.vector/-activity-view-model-owner/#extension-functions","text":"Name Summary context fun ViewModelOwner .context(): Context Get access to Context from a ViewModelOwner .","title":"Extension Functions"},{"location":"api/vector/com.haroldadmin.vector/-activity-view-model-owner/-init-/","text":"vector / com.haroldadmin.vector / ActivityViewModelOwner / <init> <init> \u00b6 ActivityViewModelOwner(activity: ComponentActivity ) Creates a ViewModelOwner wrapping the given Activity Constructor Creates a ViewModelOwner wrapping the given Activity","title":" init "},{"location":"api/vector/com.haroldadmin.vector/-activity-view-model-owner/-init-/#init","text":"ActivityViewModelOwner(activity: ComponentActivity ) Creates a ViewModelOwner wrapping the given Activity Constructor Creates a ViewModelOwner wrapping the given Activity","title":"&lt;init&gt;"},{"location":"api/vector/com.haroldadmin.vector/-activity-view-model-owner/activity/","text":"vector / com.haroldadmin.vector / ActivityViewModelOwner / activity activity \u00b6 fun <A : FragmentActivity > activity(): A Get a type-casted version of the wrapped activity Parameters \u00b6 A - The type of your Activity Exceptions \u00b6 ClassCastException - If the wrapped activity can not be casted to given activity type val activity: ComponentActivity The underlying activity of this ViewModelOwner Property \u00b6 activity - The underlying activity of this ViewModelOwner","title":"Activity"},{"location":"api/vector/com.haroldadmin.vector/-activity-view-model-owner/activity/#activity","text":"fun <A : FragmentActivity > activity(): A Get a type-casted version of the wrapped activity","title":"activity"},{"location":"api/vector/com.haroldadmin.vector/-activity-view-model-owner/activity/#parameters","text":"A - The type of your Activity","title":"Parameters"},{"location":"api/vector/com.haroldadmin.vector/-activity-view-model-owner/activity/#exceptions","text":"ClassCastException - If the wrapped activity can not be casted to given activity type val activity: ComponentActivity The underlying activity of this ViewModelOwner","title":"Exceptions"},{"location":"api/vector/com.haroldadmin.vector/-activity-view-model-owner/activity/#property","text":"activity - The underlying activity of this ViewModelOwner","title":"Property"},{"location":"api/vector/com.haroldadmin.vector/-fragment-view-model-owner/","text":"vector / com.haroldadmin.vector / FragmentViewModelOwner FragmentViewModelOwner \u00b6 class FragmentViewModelOwner : ViewModelOwner A ViewModelOwner which wraps the parent fragment of a ViewModel Constructors \u00b6 Name Summary <init> FragmentViewModelOwner(fragment: Fragment , args: Bundle ? = fragment.arguments) Creates a ViewModelOwner wrapping the given Fragment Properties \u00b6 Name Summary fragment val fragment: Fragment The parent fragment wrapped in this class Functions \u00b6 Name Summary activity fun <A : FragmentActivity > activity(): A Get a type-casted version of the parent activity of the wrapped fragment args fun args(): Bundle ? Get the arguments bundle wrapped in this class fragment fun <F : Fragment > fragment(): F Get a type-casted version of the parent fragment wrapped in this class Extension Functions \u00b6 Name Summary context fun ViewModelOwner .context(): Context Get access to Context from a ViewModelOwner .","title":"Home"},{"location":"api/vector/com.haroldadmin.vector/-fragment-view-model-owner/#fragmentviewmodelowner","text":"class FragmentViewModelOwner : ViewModelOwner A ViewModelOwner which wraps the parent fragment of a ViewModel","title":"FragmentViewModelOwner"},{"location":"api/vector/com.haroldadmin.vector/-fragment-view-model-owner/#constructors","text":"Name Summary <init> FragmentViewModelOwner(fragment: Fragment , args: Bundle ? = fragment.arguments) Creates a ViewModelOwner wrapping the given Fragment","title":"Constructors"},{"location":"api/vector/com.haroldadmin.vector/-fragment-view-model-owner/#properties","text":"Name Summary fragment val fragment: Fragment The parent fragment wrapped in this class","title":"Properties"},{"location":"api/vector/com.haroldadmin.vector/-fragment-view-model-owner/#functions","text":"Name Summary activity fun <A : FragmentActivity > activity(): A Get a type-casted version of the parent activity of the wrapped fragment args fun args(): Bundle ? Get the arguments bundle wrapped in this class fragment fun <F : Fragment > fragment(): F Get a type-casted version of the parent fragment wrapped in this class","title":"Functions"},{"location":"api/vector/com.haroldadmin.vector/-fragment-view-model-owner/#extension-functions","text":"Name Summary context fun ViewModelOwner .context(): Context Get access to Context from a ViewModelOwner .","title":"Extension Functions"},{"location":"api/vector/com.haroldadmin.vector/-fragment-view-model-owner/-init-/","text":"vector / com.haroldadmin.vector / FragmentViewModelOwner / <init> <init> \u00b6 FragmentViewModelOwner(fragment: Fragment , args: Bundle ? = fragment.arguments) Creates a ViewModelOwner wrapping the given Fragment Constructor Creates a ViewModelOwner wrapping the given Fragment","title":" init "},{"location":"api/vector/com.haroldadmin.vector/-fragment-view-model-owner/-init-/#init","text":"FragmentViewModelOwner(fragment: Fragment , args: Bundle ? = fragment.arguments) Creates a ViewModelOwner wrapping the given Fragment Constructor Creates a ViewModelOwner wrapping the given Fragment","title":"&lt;init&gt;"},{"location":"api/vector/com.haroldadmin.vector/-fragment-view-model-owner/activity/","text":"vector / com.haroldadmin.vector / FragmentViewModelOwner / activity activity \u00b6 fun <A : FragmentActivity > activity(): A Get a type-casted version of the parent activity of the wrapped fragment Parameters \u00b6 A - The type of the parent activity","title":"Activity"},{"location":"api/vector/com.haroldadmin.vector/-fragment-view-model-owner/activity/#activity","text":"fun <A : FragmentActivity > activity(): A Get a type-casted version of the parent activity of the wrapped fragment","title":"activity"},{"location":"api/vector/com.haroldadmin.vector/-fragment-view-model-owner/activity/#parameters","text":"A - The type of the parent activity","title":"Parameters"},{"location":"api/vector/com.haroldadmin.vector/-fragment-view-model-owner/args/","text":"vector / com.haroldadmin.vector / FragmentViewModelOwner / args args \u00b6 fun args(): Bundle ? Get the arguments bundle wrapped in this class","title":"Args"},{"location":"api/vector/com.haroldadmin.vector/-fragment-view-model-owner/args/#args","text":"fun args(): Bundle ? Get the arguments bundle wrapped in this class","title":"args"},{"location":"api/vector/com.haroldadmin.vector/-fragment-view-model-owner/fragment/","text":"vector / com.haroldadmin.vector / FragmentViewModelOwner / fragment fragment \u00b6 fun <F : Fragment > fragment(): F Get a type-casted version of the parent fragment wrapped in this class Parameters \u00b6 F - The type of the parent activity val fragment: Fragment The parent fragment wrapped in this class Property \u00b6 fragment - The parent fragment wrapped in this class","title":"Fragment"},{"location":"api/vector/com.haroldadmin.vector/-fragment-view-model-owner/fragment/#fragment","text":"fun <F : Fragment > fragment(): F Get a type-casted version of the parent fragment wrapped in this class","title":"fragment"},{"location":"api/vector/com.haroldadmin.vector/-fragment-view-model-owner/fragment/#parameters","text":"F - The type of the parent activity val fragment: Fragment The parent fragment wrapped in this class","title":"Parameters"},{"location":"api/vector/com.haroldadmin.vector/-fragment-view-model-owner/fragment/#property","text":"fragment - The parent fragment wrapped in this class","title":"Property"},{"location":"api/vector/com.haroldadmin.vector/-saved-state-vector-view-model/","text":"vector / com.haroldadmin.vector / SavedStateVectorViewModel SavedStateVectorViewModel \u00b6 abstract class SavedStateVectorViewModel<S : VectorState > : VectorViewModel < S > A Subclass of VectorViewModel that has access to a SavedStateHandle to easily persist state properties in case of process death Parameters \u00b6 initialState - The initial state for this ViewModel stateStoreContext - The CoroutineContext to be used with the contained State Store savedStateHandle - The SavedStateHandle to be used for persisting state across process deaths Constructors \u00b6 Name Summary <init> SavedStateVectorViewModel(initialState: S , stateStoreContext: CoroutineContext = Dispatchers.Default + Job(), savedStateHandle: SavedStateHandle ) A Subclass of VectorViewModel that has access to a SavedStateHandle to easily persist state properties in case of process death Properties \u00b6 Name Summary savedStateHandle val savedStateHandle: SavedStateHandle The SavedStateHandle to be used for persisting state across process deaths Inherited Properties \u00b6 Name Summary currentState val currentState: S Access the current value of state stored in the stateStore . logger val logger: Logger state val state: Flow< S > A kotlinx.coroutines.flow.Flow of VectorState which can be observed by external classes to respond to changes in state. stateStore open val stateStore: StateStore < S > The state store associated with this ViewModel Functions \u00b6 Name Summary persistState open fun persistState(): Unit Saves the current state into savedStateHandle using KEY_SAVED_STATE Subclasses can override this method for custom behaviour. setStateAndPersist fun setStateAndPersist(reducer: suspend S .() -> S ): Unit A convenience wrapper around the setState function which runs the given reducer, and then persists the newly created state Inherited Functions \u00b6 Name Summary onCleared open fun onCleared(): Unit Clears this ViewModel as well as its stateStore . setState fun setState(action: suspend S .() -> S ): Unit The only method through which state mutation is allowed in subclasses. withState fun withState(action: suspend ( S ) -> Unit ): Unit Dispatch the given action the stateStore . This action shall be processed as soon as all existing state reducers have been processed. The state parameter supplied to this action should be the latest value at the time of processing of this action Companion Object Properties \u00b6 Name Summary KEY_SAVED_STATE const val KEY_SAVED_STATE: String A predefined key which can be used to persist a valid VectorState class into the savedStateHandle","title":"Home"},{"location":"api/vector/com.haroldadmin.vector/-saved-state-vector-view-model/#savedstatevectorviewmodel","text":"abstract class SavedStateVectorViewModel<S : VectorState > : VectorViewModel < S > A Subclass of VectorViewModel that has access to a SavedStateHandle to easily persist state properties in case of process death","title":"SavedStateVectorViewModel"},{"location":"api/vector/com.haroldadmin.vector/-saved-state-vector-view-model/#parameters","text":"initialState - The initial state for this ViewModel stateStoreContext - The CoroutineContext to be used with the contained State Store savedStateHandle - The SavedStateHandle to be used for persisting state across process deaths","title":"Parameters"},{"location":"api/vector/com.haroldadmin.vector/-saved-state-vector-view-model/#constructors","text":"Name Summary <init> SavedStateVectorViewModel(initialState: S , stateStoreContext: CoroutineContext = Dispatchers.Default + Job(), savedStateHandle: SavedStateHandle ) A Subclass of VectorViewModel that has access to a SavedStateHandle to easily persist state properties in case of process death","title":"Constructors"},{"location":"api/vector/com.haroldadmin.vector/-saved-state-vector-view-model/#properties","text":"Name Summary savedStateHandle val savedStateHandle: SavedStateHandle The SavedStateHandle to be used for persisting state across process deaths","title":"Properties"},{"location":"api/vector/com.haroldadmin.vector/-saved-state-vector-view-model/#inherited-properties","text":"Name Summary currentState val currentState: S Access the current value of state stored in the stateStore . logger val logger: Logger state val state: Flow< S > A kotlinx.coroutines.flow.Flow of VectorState which can be observed by external classes to respond to changes in state. stateStore open val stateStore: StateStore < S > The state store associated with this ViewModel","title":"Inherited Properties"},{"location":"api/vector/com.haroldadmin.vector/-saved-state-vector-view-model/#functions","text":"Name Summary persistState open fun persistState(): Unit Saves the current state into savedStateHandle using KEY_SAVED_STATE Subclasses can override this method for custom behaviour. setStateAndPersist fun setStateAndPersist(reducer: suspend S .() -> S ): Unit A convenience wrapper around the setState function which runs the given reducer, and then persists the newly created state","title":"Functions"},{"location":"api/vector/com.haroldadmin.vector/-saved-state-vector-view-model/#inherited-functions","text":"Name Summary onCleared open fun onCleared(): Unit Clears this ViewModel as well as its stateStore . setState fun setState(action: suspend S .() -> S ): Unit The only method through which state mutation is allowed in subclasses. withState fun withState(action: suspend ( S ) -> Unit ): Unit Dispatch the given action the stateStore . This action shall be processed as soon as all existing state reducers have been processed. The state parameter supplied to this action should be the latest value at the time of processing of this action","title":"Inherited Functions"},{"location":"api/vector/com.haroldadmin.vector/-saved-state-vector-view-model/#companion-object-properties","text":"Name Summary KEY_SAVED_STATE const val KEY_SAVED_STATE: String A predefined key which can be used to persist a valid VectorState class into the savedStateHandle","title":"Companion Object Properties"},{"location":"api/vector/com.haroldadmin.vector/-saved-state-vector-view-model/-init-/","text":"vector / com.haroldadmin.vector / SavedStateVectorViewModel / <init> <init> \u00b6 SavedStateVectorViewModel(initialState: S , stateStoreContext: CoroutineContext = Dispatchers.Default + Job(), savedStateHandle: SavedStateHandle ) A Subclass of VectorViewModel that has access to a SavedStateHandle to easily persist state properties in case of process death Parameters \u00b6 initialState - The initial state for this ViewModel stateStoreContext - The CoroutineContext to be used with the contained State Store savedStateHandle - The SavedStateHandle to be used for persisting state across process deaths","title":" init "},{"location":"api/vector/com.haroldadmin.vector/-saved-state-vector-view-model/-init-/#init","text":"SavedStateVectorViewModel(initialState: S , stateStoreContext: CoroutineContext = Dispatchers.Default + Job(), savedStateHandle: SavedStateHandle ) A Subclass of VectorViewModel that has access to a SavedStateHandle to easily persist state properties in case of process death","title":"&lt;init&gt;"},{"location":"api/vector/com.haroldadmin.vector/-saved-state-vector-view-model/-init-/#parameters","text":"initialState - The initial state for this ViewModel stateStoreContext - The CoroutineContext to be used with the contained State Store savedStateHandle - The SavedStateHandle to be used for persisting state across process deaths","title":"Parameters"},{"location":"api/vector/com.haroldadmin.vector/-saved-state-vector-view-model/-k-e-y_-s-a-v-e-d_-s-t-a-t-e/","text":"vector / com.haroldadmin.vector / SavedStateVectorViewModel / KEY_SAVED_STATE KEY_SAVED_STATE \u00b6 const val KEY_SAVED_STATE: String A predefined key which can be used to persist a valid VectorState class into the savedStateHandle","title":" k e y  s a v e d  s t a t e"},{"location":"api/vector/com.haroldadmin.vector/-saved-state-vector-view-model/-k-e-y_-s-a-v-e-d_-s-t-a-t-e/#key_saved_state","text":"const val KEY_SAVED_STATE: String A predefined key which can be used to persist a valid VectorState class into the savedStateHandle","title":"KEY_SAVED_STATE"},{"location":"api/vector/com.haroldadmin.vector/-saved-state-vector-view-model/persist-state/","text":"vector / com.haroldadmin.vector / SavedStateVectorViewModel / persistState persistState \u00b6 protected open fun persistState(): Unit Saves the current state into savedStateHandle using KEY_SAVED_STATE Subclasses can override this method for custom behaviour.","title":"Persist state"},{"location":"api/vector/com.haroldadmin.vector/-saved-state-vector-view-model/persist-state/#persiststate","text":"protected open fun persistState(): Unit Saves the current state into savedStateHandle using KEY_SAVED_STATE Subclasses can override this method for custom behaviour.","title":"persistState"},{"location":"api/vector/com.haroldadmin.vector/-saved-state-vector-view-model/saved-state-handle/","text":"vector / com.haroldadmin.vector / SavedStateVectorViewModel / savedStateHandle savedStateHandle \u00b6 protected val savedStateHandle: SavedStateHandle The SavedStateHandle to be used for persisting state across process deaths","title":"Saved state handle"},{"location":"api/vector/com.haroldadmin.vector/-saved-state-vector-view-model/saved-state-handle/#savedstatehandle","text":"protected val savedStateHandle: SavedStateHandle The SavedStateHandle to be used for persisting state across process deaths","title":"savedStateHandle"},{"location":"api/vector/com.haroldadmin.vector/-saved-state-vector-view-model/set-state-and-persist/","text":"vector / com.haroldadmin.vector / SavedStateVectorViewModel / setStateAndPersist setStateAndPersist \u00b6 protected fun setStateAndPersist(reducer: suspend S .() -> S ): Unit A convenience wrapper around the setState function which runs the given reducer, and then persists the newly created state Parameters \u00b6 reducer - The state reducer to create a new state from the current state","title":"Set state and persist"},{"location":"api/vector/com.haroldadmin.vector/-saved-state-vector-view-model/set-state-and-persist/#setstateandpersist","text":"protected fun setStateAndPersist(reducer: suspend S .() -> S ): Unit A convenience wrapper around the setState function which runs the given reducer, and then persists the newly created state","title":"setStateAndPersist"},{"location":"api/vector/com.haroldadmin.vector/-saved-state-vector-view-model/set-state-and-persist/#parameters","text":"reducer - The state reducer to create a new state from the current state","title":"Parameters"},{"location":"api/vector/com.haroldadmin.vector/-vector/","text":"vector / com.haroldadmin.vector / Vector Vector \u00b6 object Vector Singleton object to configure the library Properties \u00b6 Name Summary enableLogging var enableLogging: Boolean Enables/Disables logging based on its value","title":"Home"},{"location":"api/vector/com.haroldadmin.vector/-vector/#vector","text":"object Vector Singleton object to configure the library","title":"Vector"},{"location":"api/vector/com.haroldadmin.vector/-vector/#properties","text":"Name Summary enableLogging var enableLogging: Boolean Enables/Disables logging based on its value","title":"Properties"},{"location":"api/vector/com.haroldadmin.vector/-vector/enable-logging/","text":"vector / com.haroldadmin.vector / Vector / enableLogging enableLogging \u00b6 var enableLogging: Boolean Enables/Disables logging based on its value If true, then all loggers shall write their logs. If false, then no loggers shall write any logs. Can be changed at runtime.","title":"Enable logging"},{"location":"api/vector/com.haroldadmin.vector/-vector/enable-logging/#enablelogging","text":"var enableLogging: Boolean Enables/Disables logging based on its value If true, then all loggers shall write their logs. If false, then no loggers shall write any logs. Can be changed at runtime.","title":"enableLogging"},{"location":"api/vector/com.haroldadmin.vector/-vector-fragment/","text":"vector / com.haroldadmin.vector / VectorFragment VectorFragment \u00b6 abstract class VectorFragment : Fragment A Fragment which has a convenient fragmentScope property to easily launch coroutines in it. Constructors \u00b6 Name Summary <init> VectorFragment() A Fragment which has a convenient fragmentScope property to easily launch coroutines in it. Properties \u00b6 Name Summary fragmentScope open val fragmentScope: CoroutineScope A CoroutineScope associated with the lifecycle of this fragment. The scope is cancelled when onDestroy of this Fragment has been called. logger open val logger: Logger viewScope open val viewScope: CoroutineScope A CoroutineScope associated with the view-lifecycle of this fragment. The scope is cancelled when onDestroyView of this Fragment has been called, and created when onCreateView is called. Functions \u00b6 Name Summary onDestroy open fun onDestroy(): Unit Cancels the fragmentScope renderState fun <S : VectorState > renderState(state: S , renderer: ( S ) -> Unit ): Unit Renders the UI based on the given state parameter using the renderer block. If your fragment is tied to a VectorViewModel then consider using the overloaded version of the method which takes in a viewModel as an input parameter. Must be called after the Fragment view has been created ( onViewCreated ) fun <S : VectorState > renderState(viewModel: VectorViewModel < S >, renderer: ( S ) -> Unit ): Unit Renders the UI based on emitted state updates from the given viewModel using the renderer block. MUST BE CALLED IN onViewCreated() Extension Functions \u00b6 Name Summary activityViewModel fun <VM : VectorViewModel < S >, S : VectorState > Fragment .activityViewModel(stateStoreContext: CoroutineContext = Dispatchers.Default + Job()): vectorLazy < VM > Lazy delegate for creating an activity scoped VectorViewModel from a Fragment. Creates and returns the requested VectorViewModel automatically using reflection. The returned ViewModel is scoped to this Fragment's parent activity. fun <VM : VectorViewModel < S >, S : VectorState > Fragment .activityViewModel(viewModelCreator: (initialState: S , handle: SavedStateHandle ) -> VM ): vectorLazy < VM > Lazy delegate for creating a parent activity scoped VectorViewModel from a Fragment using the given producer lambda activityViewModelOwner fun Fragment .activityViewModelOwner(): ActivityViewModelOwner Creates a ViewModelOwner from the parent activity of this Fragment fragmentViewModel fun <VM : VectorViewModel < S >, S : VectorState > Fragment .fragmentViewModel(stateStoreContext: CoroutineContext = Dispatchers.Default + Job()): vectorLazy < VM > Lazy delegate for creating a VectorViewModel from a Fragment fun <VM : VectorViewModel < S >, S : VectorState > Fragment .fragmentViewModel(viewModelCreator: (initialState: S , handle: SavedStateHandle ) -> VM ): vectorLazy < VM > Lazy delegate for creating a VectorViewModel from a Fragment using the given producer lambda fragmentViewModelOwner fun Fragment .fragmentViewModelOwner(): FragmentViewModelOwner Creates a ViewModelOwner from this Fragment","title":"Home"},{"location":"api/vector/com.haroldadmin.vector/-vector-fragment/#vectorfragment","text":"abstract class VectorFragment : Fragment A Fragment which has a convenient fragmentScope property to easily launch coroutines in it.","title":"VectorFragment"},{"location":"api/vector/com.haroldadmin.vector/-vector-fragment/#constructors","text":"Name Summary <init> VectorFragment() A Fragment which has a convenient fragmentScope property to easily launch coroutines in it.","title":"Constructors"},{"location":"api/vector/com.haroldadmin.vector/-vector-fragment/#properties","text":"Name Summary fragmentScope open val fragmentScope: CoroutineScope A CoroutineScope associated with the lifecycle of this fragment. The scope is cancelled when onDestroy of this Fragment has been called. logger open val logger: Logger viewScope open val viewScope: CoroutineScope A CoroutineScope associated with the view-lifecycle of this fragment. The scope is cancelled when onDestroyView of this Fragment has been called, and created when onCreateView is called.","title":"Properties"},{"location":"api/vector/com.haroldadmin.vector/-vector-fragment/#functions","text":"Name Summary onDestroy open fun onDestroy(): Unit Cancels the fragmentScope renderState fun <S : VectorState > renderState(state: S , renderer: ( S ) -> Unit ): Unit Renders the UI based on the given state parameter using the renderer block. If your fragment is tied to a VectorViewModel then consider using the overloaded version of the method which takes in a viewModel as an input parameter. Must be called after the Fragment view has been created ( onViewCreated ) fun <S : VectorState > renderState(viewModel: VectorViewModel < S >, renderer: ( S ) -> Unit ): Unit Renders the UI based on emitted state updates from the given viewModel using the renderer block. MUST BE CALLED IN onViewCreated()","title":"Functions"},{"location":"api/vector/com.haroldadmin.vector/-vector-fragment/#extension-functions","text":"Name Summary activityViewModel fun <VM : VectorViewModel < S >, S : VectorState > Fragment .activityViewModel(stateStoreContext: CoroutineContext = Dispatchers.Default + Job()): vectorLazy < VM > Lazy delegate for creating an activity scoped VectorViewModel from a Fragment. Creates and returns the requested VectorViewModel automatically using reflection. The returned ViewModel is scoped to this Fragment's parent activity. fun <VM : VectorViewModel < S >, S : VectorState > Fragment .activityViewModel(viewModelCreator: (initialState: S , handle: SavedStateHandle ) -> VM ): vectorLazy < VM > Lazy delegate for creating a parent activity scoped VectorViewModel from a Fragment using the given producer lambda activityViewModelOwner fun Fragment .activityViewModelOwner(): ActivityViewModelOwner Creates a ViewModelOwner from the parent activity of this Fragment fragmentViewModel fun <VM : VectorViewModel < S >, S : VectorState > Fragment .fragmentViewModel(stateStoreContext: CoroutineContext = Dispatchers.Default + Job()): vectorLazy < VM > Lazy delegate for creating a VectorViewModel from a Fragment fun <VM : VectorViewModel < S >, S : VectorState > Fragment .fragmentViewModel(viewModelCreator: (initialState: S , handle: SavedStateHandle ) -> VM ): vectorLazy < VM > Lazy delegate for creating a VectorViewModel from a Fragment using the given producer lambda fragmentViewModelOwner fun Fragment .fragmentViewModelOwner(): FragmentViewModelOwner Creates a ViewModelOwner from this Fragment","title":"Extension Functions"},{"location":"api/vector/com.haroldadmin.vector/-vector-fragment/-init-/","text":"vector / com.haroldadmin.vector / VectorFragment / <init> <init> \u00b6 VectorFragment() A Fragment which has a convenient fragmentScope property to easily launch coroutines in it.","title":" init "},{"location":"api/vector/com.haroldadmin.vector/-vector-fragment/-init-/#init","text":"VectorFragment() A Fragment which has a convenient fragmentScope property to easily launch coroutines in it.","title":"&lt;init&gt;"},{"location":"api/vector/com.haroldadmin.vector/-vector-fragment/fragment-scope/","text":"vector / com.haroldadmin.vector / VectorFragment / fragmentScope fragmentScope \u00b6 protected open val fragmentScope: CoroutineScope A CoroutineScope associated with the lifecycle of this fragment. The scope is cancelled when onDestroy of this Fragment has been called. Getter A CoroutineScope associated with the lifecycle of this fragment. The scope is cancelled when onDestroy of this Fragment has been called.","title":"Fragment scope"},{"location":"api/vector/com.haroldadmin.vector/-vector-fragment/fragment-scope/#fragmentscope","text":"protected open val fragmentScope: CoroutineScope A CoroutineScope associated with the lifecycle of this fragment. The scope is cancelled when onDestroy of this Fragment has been called. Getter A CoroutineScope associated with the lifecycle of this fragment. The scope is cancelled when onDestroy of this Fragment has been called.","title":"fragmentScope"},{"location":"api/vector/com.haroldadmin.vector/-vector-fragment/logger/","text":"vector / com.haroldadmin.vector / VectorFragment / logger logger \u00b6 protected open val logger: Logger","title":"Logger"},{"location":"api/vector/com.haroldadmin.vector/-vector-fragment/logger/#logger","text":"protected open val logger: Logger","title":"logger"},{"location":"api/vector/com.haroldadmin.vector/-vector-fragment/on-destroy/","text":"vector / com.haroldadmin.vector / VectorFragment / onDestroy onDestroy \u00b6 open fun onDestroy(): Unit Cancels the fragmentScope","title":"On destroy"},{"location":"api/vector/com.haroldadmin.vector/-vector-fragment/on-destroy/#ondestroy","text":"open fun onDestroy(): Unit Cancels the fragmentScope","title":"onDestroy"},{"location":"api/vector/com.haroldadmin.vector/-vector-fragment/render-state/","text":"vector / com.haroldadmin.vector / VectorFragment / renderState renderState \u00b6 protected inline fun <reified S : VectorState > renderState(state: S , renderer: ( S ) -> Unit ): Unit Renders the UI based on the given state parameter using the renderer block. If your fragment is tied to a VectorViewModel then consider using the overloaded version of the method which takes in a viewModel as an input parameter. Must be called after the Fragment view has been created ( onViewCreated ) Parameters \u00b6 state - The state instance using which the UI should be rendered renderer - The method which updates the UI state protected inline fun <S : VectorState > renderState(viewModel: VectorViewModel < S >, crossinline renderer: ( S ) -> Unit ): Unit Renders the UI based on emitted state updates from the given viewModel using the renderer block. MUST BE CALLED IN onViewCreated() Launches a coroutine in viewScope which collects state updates from the given viewModel and calls the renderer method on it. Since the renderer method might contain references to views, and also since this method should only run while the view of the fragment is available, it is launched in the viewScope rather than the fragmentScope . As such, it must be called in onViewCreated after the viewScope is available and the view can be updated. The collection of state updates automatically stops when onDestroyView is called. Parameters \u00b6 viewModel - The ViewModel whose VectorViewModel.state flow is used to receive state updates and render the UI renderer - The method which updates the UI","title":"Render state"},{"location":"api/vector/com.haroldadmin.vector/-vector-fragment/render-state/#renderstate","text":"protected inline fun <reified S : VectorState > renderState(state: S , renderer: ( S ) -> Unit ): Unit Renders the UI based on the given state parameter using the renderer block. If your fragment is tied to a VectorViewModel then consider using the overloaded version of the method which takes in a viewModel as an input parameter. Must be called after the Fragment view has been created ( onViewCreated )","title":"renderState"},{"location":"api/vector/com.haroldadmin.vector/-vector-fragment/render-state/#parameters","text":"state - The state instance using which the UI should be rendered renderer - The method which updates the UI state protected inline fun <S : VectorState > renderState(viewModel: VectorViewModel < S >, crossinline renderer: ( S ) -> Unit ): Unit Renders the UI based on emitted state updates from the given viewModel using the renderer block. MUST BE CALLED IN onViewCreated() Launches a coroutine in viewScope which collects state updates from the given viewModel and calls the renderer method on it. Since the renderer method might contain references to views, and also since this method should only run while the view of the fragment is available, it is launched in the viewScope rather than the fragmentScope . As such, it must be called in onViewCreated after the viewScope is available and the view can be updated. The collection of state updates automatically stops when onDestroyView is called.","title":"Parameters"},{"location":"api/vector/com.haroldadmin.vector/-vector-fragment/render-state/#parameters_1","text":"viewModel - The ViewModel whose VectorViewModel.state flow is used to receive state updates and render the UI renderer - The method which updates the UI","title":"Parameters"},{"location":"api/vector/com.haroldadmin.vector/-vector-fragment/view-scope/","text":"vector / com.haroldadmin.vector / VectorFragment / viewScope viewScope \u00b6 protected open val viewScope: CoroutineScope A CoroutineScope associated with the view-lifecycle of this fragment. The scope is cancelled when onDestroyView of this Fragment has been called, and created when onCreateView is called. It delegates to the lifecycle-runtime library's androidx.lifecycle.lifecycleScope extension","title":"View scope"},{"location":"api/vector/com.haroldadmin.vector/-vector-fragment/view-scope/#viewscope","text":"protected open val viewScope: CoroutineScope A CoroutineScope associated with the view-lifecycle of this fragment. The scope is cancelled when onDestroyView of this Fragment has been called, and created when onCreateView is called. It delegates to the lifecycle-runtime library's androidx.lifecycle.lifecycleScope extension","title":"viewScope"},{"location":"api/vector/com.haroldadmin.vector/-vector-view-model/","text":"vector / com.haroldadmin.vector / VectorViewModel VectorViewModel \u00b6 abstract class VectorViewModel<S : VectorState > : ViewModel The Base ViewModel class your ViewModel should inherit from Parameters \u00b6 S - The state class for this ViewModel implementing VectorState initialState - The initial state for this ViewModel stateStoreContext - The CoroutineContext to be used with the state store A VectorViewModel can implement the VectorViewModelFactory in its Companion object to provide ways to create the initial state, as well as the ViewModel itself. Constructors \u00b6 Name Summary <init> VectorViewModel(initialState: S , stateStoreContext: CoroutineContext = Dispatchers.Default + Job()) The Base ViewModel class your ViewModel should inherit from Properties \u00b6 Name Summary currentState val currentState: S Access the current value of state stored in the stateStore . logger val logger: Logger state val state: Flow< S > A kotlinx.coroutines.flow.Flow of VectorState which can be observed by external classes to respond to changes in state. stateStore open val stateStore: StateStore < S > The state store associated with this ViewModel Functions \u00b6 Name Summary onCleared open fun onCleared(): Unit Clears this ViewModel as well as its stateStore . setState fun setState(action: suspend S .() -> S ): Unit The only method through which state mutation is allowed in subclasses. withState fun withState(action: suspend ( S ) -> Unit ): Unit Dispatch the given action the stateStore . This action shall be processed as soon as all existing state reducers have been processed. The state parameter supplied to this action should be the latest value at the time of processing of this action Inheritors \u00b6 Name Summary SavedStateVectorViewModel abstract class SavedStateVectorViewModel<S : VectorState > : VectorViewModel < S > A Subclass of VectorViewModel that has access to a SavedStateHandle to easily persist state properties in case of process death","title":"Home"},{"location":"api/vector/com.haroldadmin.vector/-vector-view-model/#vectorviewmodel","text":"abstract class VectorViewModel<S : VectorState > : ViewModel The Base ViewModel class your ViewModel should inherit from","title":"VectorViewModel"},{"location":"api/vector/com.haroldadmin.vector/-vector-view-model/#parameters","text":"S - The state class for this ViewModel implementing VectorState initialState - The initial state for this ViewModel stateStoreContext - The CoroutineContext to be used with the state store A VectorViewModel can implement the VectorViewModelFactory in its Companion object to provide ways to create the initial state, as well as the ViewModel itself.","title":"Parameters"},{"location":"api/vector/com.haroldadmin.vector/-vector-view-model/#constructors","text":"Name Summary <init> VectorViewModel(initialState: S , stateStoreContext: CoroutineContext = Dispatchers.Default + Job()) The Base ViewModel class your ViewModel should inherit from","title":"Constructors"},{"location":"api/vector/com.haroldadmin.vector/-vector-view-model/#properties","text":"Name Summary currentState val currentState: S Access the current value of state stored in the stateStore . logger val logger: Logger state val state: Flow< S > A kotlinx.coroutines.flow.Flow of VectorState which can be observed by external classes to respond to changes in state. stateStore open val stateStore: StateStore < S > The state store associated with this ViewModel","title":"Properties"},{"location":"api/vector/com.haroldadmin.vector/-vector-view-model/#functions","text":"Name Summary onCleared open fun onCleared(): Unit Clears this ViewModel as well as its stateStore . setState fun setState(action: suspend S .() -> S ): Unit The only method through which state mutation is allowed in subclasses. withState fun withState(action: suspend ( S ) -> Unit ): Unit Dispatch the given action the stateStore . This action shall be processed as soon as all existing state reducers have been processed. The state parameter supplied to this action should be the latest value at the time of processing of this action","title":"Functions"},{"location":"api/vector/com.haroldadmin.vector/-vector-view-model/#inheritors","text":"Name Summary SavedStateVectorViewModel abstract class SavedStateVectorViewModel<S : VectorState > : VectorViewModel < S > A Subclass of VectorViewModel that has access to a SavedStateHandle to easily persist state properties in case of process death","title":"Inheritors"},{"location":"api/vector/com.haroldadmin.vector/-vector-view-model/-init-/","text":"vector / com.haroldadmin.vector / VectorViewModel / <init> <init> \u00b6 VectorViewModel(initialState: S , stateStoreContext: CoroutineContext = Dispatchers.Default + Job()) The Base ViewModel class your ViewModel should inherit from Parameters \u00b6 S - The state class for this ViewModel implementing VectorState initialState - The initial state for this ViewModel stateStoreContext - The CoroutineContext to be used with the state store A VectorViewModel can implement the VectorViewModelFactory in its Companion object to provide ways to create the initial state, as well as the ViewModel itself.","title":" init "},{"location":"api/vector/com.haroldadmin.vector/-vector-view-model/-init-/#init","text":"VectorViewModel(initialState: S , stateStoreContext: CoroutineContext = Dispatchers.Default + Job()) The Base ViewModel class your ViewModel should inherit from","title":"&lt;init&gt;"},{"location":"api/vector/com.haroldadmin.vector/-vector-view-model/-init-/#parameters","text":"S - The state class for this ViewModel implementing VectorState initialState - The initial state for this ViewModel stateStoreContext - The CoroutineContext to be used with the state store A VectorViewModel can implement the VectorViewModelFactory in its Companion object to provide ways to create the initial state, as well as the ViewModel itself.","title":"Parameters"},{"location":"api/vector/com.haroldadmin.vector/-vector-view-model/current-state/","text":"vector / com.haroldadmin.vector / VectorViewModel / currentState currentState \u00b6 val currentState: S Access the current value of state stored in the stateStore . THIS VALUE OF STATE IS NOT GUARANTEED TO BE UP TO DATE This property is only meant to be used by external classes who need to get hold of the current state without having to subscribe to it. For use cases where the current state is needed to be accessed inside the ViewModel, the withState method should be used","title":"Current state"},{"location":"api/vector/com.haroldadmin.vector/-vector-view-model/current-state/#currentstate","text":"val currentState: S Access the current value of state stored in the stateStore . THIS VALUE OF STATE IS NOT GUARANTEED TO BE UP TO DATE This property is only meant to be used by external classes who need to get hold of the current state without having to subscribe to it. For use cases where the current state is needed to be accessed inside the ViewModel, the withState method should be used","title":"currentState"},{"location":"api/vector/com.haroldadmin.vector/-vector-view-model/logger/","text":"vector / com.haroldadmin.vector / VectorViewModel / logger logger \u00b6 protected val logger: Logger","title":"Logger"},{"location":"api/vector/com.haroldadmin.vector/-vector-view-model/logger/#logger","text":"protected val logger: Logger","title":"logger"},{"location":"api/vector/com.haroldadmin.vector/-vector-view-model/on-cleared/","text":"vector / com.haroldadmin.vector / VectorViewModel / onCleared onCleared \u00b6 @CallSuper protected open fun onCleared(): Unit Clears this ViewModel as well as its stateStore .","title":"On cleared"},{"location":"api/vector/com.haroldadmin.vector/-vector-view-model/on-cleared/#oncleared","text":"@CallSuper protected open fun onCleared(): Unit Clears this ViewModel as well as its stateStore .","title":"onCleared"},{"location":"api/vector/com.haroldadmin.vector/-vector-view-model/set-state/","text":"vector / com.haroldadmin.vector / VectorViewModel / setState setState \u00b6 protected fun setState(action: suspend S .() -> S ): Unit The only method through which state mutation is allowed in subclasses. Dispatches an action the stateStore . This action shall be processed as soon as possible in the state store, but not necessarily immediately Parameters \u00b6 action - The state reducer to create a new state from the current state","title":"Set state"},{"location":"api/vector/com.haroldadmin.vector/-vector-view-model/set-state/#setstate","text":"protected fun setState(action: suspend S .() -> S ): Unit The only method through which state mutation is allowed in subclasses. Dispatches an action the stateStore . This action shall be processed as soon as possible in the state store, but not necessarily immediately","title":"setState"},{"location":"api/vector/com.haroldadmin.vector/-vector-view-model/set-state/#parameters","text":"action - The state reducer to create a new state from the current state","title":"Parameters"},{"location":"api/vector/com.haroldadmin.vector/-vector-view-model/state-store/","text":"vector / com.haroldadmin.vector / VectorViewModel / stateStore stateStore \u00b6 protected open val stateStore: StateStore < S > The state store associated with this ViewModel","title":"State store"},{"location":"api/vector/com.haroldadmin.vector/-vector-view-model/state-store/#statestore","text":"protected open val stateStore: StateStore < S > The state store associated with this ViewModel","title":"stateStore"},{"location":"api/vector/com.haroldadmin.vector/-vector-view-model/state/","text":"vector / com.haroldadmin.vector / VectorViewModel / state state \u00b6 val state: Flow< S > A kotlinx.coroutines.flow.Flow of VectorState which can be observed by external classes to respond to changes in state. Getter A kotlinx.coroutines.flow.Flow of VectorState which can be observed by external classes to respond to changes in state.","title":"State"},{"location":"api/vector/com.haroldadmin.vector/-vector-view-model/state/#state","text":"val state: Flow< S > A kotlinx.coroutines.flow.Flow of VectorState which can be observed by external classes to respond to changes in state. Getter A kotlinx.coroutines.flow.Flow of VectorState which can be observed by external classes to respond to changes in state.","title":"state"},{"location":"api/vector/com.haroldadmin.vector/-vector-view-model/with-state/","text":"vector / com.haroldadmin.vector / VectorViewModel / withState withState \u00b6 protected fun withState(action: suspend ( S ) -> Unit ): Unit Dispatch the given action the stateStore . This action shall be processed as soon as all existing state reducers have been processed. The state parameter supplied to this action should be the latest value at the time of processing of this action Parameters \u00b6 action - The action to be performed with the current state","title":"With state"},{"location":"api/vector/com.haroldadmin.vector/-vector-view-model/with-state/#withstate","text":"protected fun withState(action: suspend ( S ) -> Unit ): Unit Dispatch the given action the stateStore . This action shall be processed as soon as all existing state reducers have been processed. The state parameter supplied to this action should be the latest value at the time of processing of this action","title":"withState"},{"location":"api/vector/com.haroldadmin.vector/-vector-view-model/with-state/#parameters","text":"action - The action to be performed with the current state","title":"Parameters"},{"location":"api/vector/com.haroldadmin.vector/-vector-view-model-factory/","text":"vector / com.haroldadmin.vector / VectorViewModelFactory VectorViewModelFactory \u00b6 interface VectorViewModelFactory<VM : VectorViewModel < S >, S : VectorState > A Factory meant to be implemented using the Companion object of a VectorViewModel to provide ways to create the initial state, as well as the creation of the ViewModel itself. Parameters \u00b6 VM - The type of the VectorViewModel being created by this factory S - The state class bound to the given VectorViewModel type Functions \u00b6 Name Summary create open fun create(initialState: S , owner: ViewModelOwner , handle: SavedStateHandle ): VM ? Used to create the requested ViewModel. This method needs to be implemented if your ViewModel has dependencies other than those of a VectorViewModel or a SavedStateVectorViewModel . However, if you are using a different kind of factory to create your ViewModel, you might skip implementing this method. initialState open fun initialState(handle: SavedStateHandle , owner: ViewModelOwner ): S ? Used to create the initial state, if this method is implemented.","title":"Home"},{"location":"api/vector/com.haroldadmin.vector/-vector-view-model-factory/#vectorviewmodelfactory","text":"interface VectorViewModelFactory<VM : VectorViewModel < S >, S : VectorState > A Factory meant to be implemented using the Companion object of a VectorViewModel to provide ways to create the initial state, as well as the creation of the ViewModel itself.","title":"VectorViewModelFactory"},{"location":"api/vector/com.haroldadmin.vector/-vector-view-model-factory/#parameters","text":"VM - The type of the VectorViewModel being created by this factory S - The state class bound to the given VectorViewModel type","title":"Parameters"},{"location":"api/vector/com.haroldadmin.vector/-vector-view-model-factory/#functions","text":"Name Summary create open fun create(initialState: S , owner: ViewModelOwner , handle: SavedStateHandle ): VM ? Used to create the requested ViewModel. This method needs to be implemented if your ViewModel has dependencies other than those of a VectorViewModel or a SavedStateVectorViewModel . However, if you are using a different kind of factory to create your ViewModel, you might skip implementing this method. initialState open fun initialState(handle: SavedStateHandle , owner: ViewModelOwner ): S ? Used to create the initial state, if this method is implemented.","title":"Functions"},{"location":"api/vector/com.haroldadmin.vector/-vector-view-model-factory/create/","text":"vector / com.haroldadmin.vector / VectorViewModelFactory / create create \u00b6 open fun create(initialState: S , owner: ViewModelOwner , handle: SavedStateHandle ): VM ? Used to create the requested ViewModel. This method needs to be implemented if your ViewModel has dependencies other than those of a VectorViewModel or a SavedStateVectorViewModel . However, if you are using a different kind of factory to create your ViewModel, you might skip implementing this method. Parameters \u00b6 initialState - The initial state to be given to the ViewModel owner - The ViewModelOwner for this ViewModel. Can be used to access context, dependency graph, etc. handle - The saved state handle to be given to the ViewModel, if needed. Return The ViewModel to be created using this function.","title":"Create"},{"location":"api/vector/com.haroldadmin.vector/-vector-view-model-factory/create/#create","text":"open fun create(initialState: S , owner: ViewModelOwner , handle: SavedStateHandle ): VM ? Used to create the requested ViewModel. This method needs to be implemented if your ViewModel has dependencies other than those of a VectorViewModel or a SavedStateVectorViewModel . However, if you are using a different kind of factory to create your ViewModel, you might skip implementing this method.","title":"create"},{"location":"api/vector/com.haroldadmin.vector/-vector-view-model-factory/create/#parameters","text":"initialState - The initial state to be given to the ViewModel owner - The ViewModelOwner for this ViewModel. Can be used to access context, dependency graph, etc. handle - The saved state handle to be given to the ViewModel, if needed. Return The ViewModel to be created using this function.","title":"Parameters"},{"location":"api/vector/com.haroldadmin.vector/-vector-view-model-factory/initial-state/","text":"vector / com.haroldadmin.vector / VectorViewModelFactory / initialState initialState \u00b6 open fun initialState(handle: SavedStateHandle , owner: ViewModelOwner ): S ? Used to create the initial state, if this method is implemented. Parameters \u00b6 handle - Can be used to retrieve last saved state before process death, using SavedStateVectorViewModel.KEY_SAVED_STATE or some other mechanism. owner - The ViewModelOwner for this ViewModel. Can be used to access fragment arguments, context etc. Return Initial state to be used for creation of the ViewModel","title":"Initial state"},{"location":"api/vector/com.haroldadmin.vector/-vector-view-model-factory/initial-state/#initialstate","text":"open fun initialState(handle: SavedStateHandle , owner: ViewModelOwner ): S ? Used to create the initial state, if this method is implemented.","title":"initialState"},{"location":"api/vector/com.haroldadmin.vector/-vector-view-model-factory/initial-state/#parameters","text":"handle - Can be used to retrieve last saved state before process death, using SavedStateVectorViewModel.KEY_SAVED_STATE or some other mechanism. owner - The ViewModelOwner for this ViewModel. Can be used to access fragment arguments, context etc. Return Initial state to be used for creation of the ViewModel","title":"Parameters"},{"location":"api/vector/com.haroldadmin.vector/-vector-view-model-provider/","text":"vector / com.haroldadmin.vector / VectorViewModelProvider VectorViewModelProvider \u00b6 object VectorViewModelProvider A class which is responsible for creating ViewModel instances. Instantiation of a ViewModel is first attempted using its companion object if it implements VectorViewModelFactory . If this fails, then the instantiation using the constructor is attempted. If this fails too, then an error is thrown. Functions \u00b6 Name Summary createViewModel fun <VM : VectorViewModel < S >, S : VectorState > createViewModel(vmClass: KClass <out VM >, stateClass: KClass <out S >, owner: ViewModelOwner , savedStateRegistryOwner: SavedStateRegistryOwner , stateStoreContext: CoroutineContext ): VM get fun <VM : VectorViewModel < S >, S : VectorState > get(vmClass: KClass <out VM >, stateClass: KClass <out S >, savedStateRegistryOwner: SavedStateRegistryOwner , viewModelOwner: ViewModelOwner , stateStoreContext: CoroutineContext ): VM Creates the requested ViewModel automatically using reflection, and returns it. The returned ViewModel is already registered with a ViewModelProvider fun <VM : VectorViewModel < S >, S : VectorState > get(vmClass: KClass <out VM >, stateClass: KClass <out S >, viewModelOwner: ViewModelOwner , savedStateRegistryOwner: SavedStateRegistryOwner , viewModelProducer: (initialState: S , handle: SavedStateHandle ) -> VM ): VM Creates and returns the requested ViewModel using the supplied viewModelProducer and returns it. The returned ViewModel is already registered with a ViewModelProvider","title":"Home"},{"location":"api/vector/com.haroldadmin.vector/-vector-view-model-provider/#vectorviewmodelprovider","text":"object VectorViewModelProvider A class which is responsible for creating ViewModel instances. Instantiation of a ViewModel is first attempted using its companion object if it implements VectorViewModelFactory . If this fails, then the instantiation using the constructor is attempted. If this fails too, then an error is thrown.","title":"VectorViewModelProvider"},{"location":"api/vector/com.haroldadmin.vector/-vector-view-model-provider/#functions","text":"Name Summary createViewModel fun <VM : VectorViewModel < S >, S : VectorState > createViewModel(vmClass: KClass <out VM >, stateClass: KClass <out S >, owner: ViewModelOwner , savedStateRegistryOwner: SavedStateRegistryOwner , stateStoreContext: CoroutineContext ): VM get fun <VM : VectorViewModel < S >, S : VectorState > get(vmClass: KClass <out VM >, stateClass: KClass <out S >, savedStateRegistryOwner: SavedStateRegistryOwner , viewModelOwner: ViewModelOwner , stateStoreContext: CoroutineContext ): VM Creates the requested ViewModel automatically using reflection, and returns it. The returned ViewModel is already registered with a ViewModelProvider fun <VM : VectorViewModel < S >, S : VectorState > get(vmClass: KClass <out VM >, stateClass: KClass <out S >, viewModelOwner: ViewModelOwner , savedStateRegistryOwner: SavedStateRegistryOwner , viewModelProducer: (initialState: S , handle: SavedStateHandle ) -> VM ): VM Creates and returns the requested ViewModel using the supplied viewModelProducer and returns it. The returned ViewModel is already registered with a ViewModelProvider","title":"Functions"},{"location":"api/vector/com.haroldadmin.vector/-vector-view-model-provider/create-view-model/","text":"vector / com.haroldadmin.vector / VectorViewModelProvider / createViewModel createViewModel \u00b6 fun <VM : VectorViewModel < S >, S : VectorState > createViewModel(vmClass: KClass <out VM >, stateClass: KClass <out S >, owner: ViewModelOwner , savedStateRegistryOwner: SavedStateRegistryOwner , stateStoreContext: CoroutineContext ): VM","title":"Create view model"},{"location":"api/vector/com.haroldadmin.vector/-vector-view-model-provider/create-view-model/#createviewmodel","text":"fun <VM : VectorViewModel < S >, S : VectorState > createViewModel(vmClass: KClass <out VM >, stateClass: KClass <out S >, owner: ViewModelOwner , savedStateRegistryOwner: SavedStateRegistryOwner , stateStoreContext: CoroutineContext ): VM","title":"createViewModel"},{"location":"api/vector/com.haroldadmin.vector/-vector-view-model-provider/get/","text":"vector / com.haroldadmin.vector / VectorViewModelProvider / get get \u00b6 fun <VM : VectorViewModel < S >, S : VectorState > get(vmClass: KClass <out VM >, stateClass: KClass <out S >, savedStateRegistryOwner: SavedStateRegistryOwner , viewModelOwner: ViewModelOwner , stateStoreContext: CoroutineContext ): VM Creates the requested ViewModel automatically using reflection, and returns it. The returned ViewModel is already registered with a ViewModelProvider fun <VM : VectorViewModel < S >, S : VectorState > get(vmClass: KClass <out VM >, stateClass: KClass <out S >, viewModelOwner: ViewModelOwner , savedStateRegistryOwner: SavedStateRegistryOwner , viewModelProducer: (initialState: S , handle: SavedStateHandle ) -> VM ): VM Creates and returns the requested ViewModel using the supplied viewModelProducer and returns it. The returned ViewModel is already registered with a ViewModelProvider","title":"Get"},{"location":"api/vector/com.haroldadmin.vector/-vector-view-model-provider/get/#get","text":"fun <VM : VectorViewModel < S >, S : VectorState > get(vmClass: KClass <out VM >, stateClass: KClass <out S >, savedStateRegistryOwner: SavedStateRegistryOwner , viewModelOwner: ViewModelOwner , stateStoreContext: CoroutineContext ): VM Creates the requested ViewModel automatically using reflection, and returns it. The returned ViewModel is already registered with a ViewModelProvider fun <VM : VectorViewModel < S >, S : VectorState > get(vmClass: KClass <out VM >, stateClass: KClass <out S >, viewModelOwner: ViewModelOwner , savedStateRegistryOwner: SavedStateRegistryOwner , viewModelProducer: (initialState: S , handle: SavedStateHandle ) -> VM ): VM Creates and returns the requested ViewModel using the supplied viewModelProducer and returns it. The returned ViewModel is already registered with a ViewModelProvider","title":"get"},{"location":"api/vector/com.haroldadmin.vector/androidx.activity.-component-activity/","text":"vector / com.haroldadmin.vector / androidx.activity.ComponentActivity Extensions for androidx.activity.ComponentActivity \u00b6 Name Summary activityViewModelOwner fun ComponentActivity .activityViewModelOwner(): ActivityViewModelOwner Creates a ViewModelOwner from this activity viewModel fun <VM : VectorViewModel < S >, S : VectorState > ComponentActivity .viewModel(stateStoreContext: CoroutineContext = Dispatchers.Default + Job()): vectorLazy < VM > Lazy delegate for creating a VectorViewModel from an Activity fun <VM : VectorViewModel < S >, S : VectorState > ComponentActivity .viewModel(viewModelCreator: (initialState: S , handle: SavedStateHandle ) -> VM ): vectorLazy < VM > Lazy delegate for creating a VectorViewModel from an Activity using the given producer lambda","title":"Home"},{"location":"api/vector/com.haroldadmin.vector/androidx.activity.-component-activity/#extensions-for-androidxactivitycomponentactivity","text":"Name Summary activityViewModelOwner fun ComponentActivity .activityViewModelOwner(): ActivityViewModelOwner Creates a ViewModelOwner from this activity viewModel fun <VM : VectorViewModel < S >, S : VectorState > ComponentActivity .viewModel(stateStoreContext: CoroutineContext = Dispatchers.Default + Job()): vectorLazy < VM > Lazy delegate for creating a VectorViewModel from an Activity fun <VM : VectorViewModel < S >, S : VectorState > ComponentActivity .viewModel(viewModelCreator: (initialState: S , handle: SavedStateHandle ) -> VM ): vectorLazy < VM > Lazy delegate for creating a VectorViewModel from an Activity using the given producer lambda","title":"Extensions for androidx.activity.ComponentActivity"},{"location":"api/vector/com.haroldadmin.vector/androidx.activity.-component-activity/activity-view-model-owner/","text":"vector / com.haroldadmin.vector / androidx.activity.ComponentActivity / activityViewModelOwner activityViewModelOwner \u00b6 fun ComponentActivity .activityViewModelOwner(): ActivityViewModelOwner Creates a ViewModelOwner from this activity","title":"Activity view model owner"},{"location":"api/vector/com.haroldadmin.vector/androidx.activity.-component-activity/activity-view-model-owner/#activityviewmodelowner","text":"fun ComponentActivity .activityViewModelOwner(): ActivityViewModelOwner Creates a ViewModelOwner from this activity","title":"activityViewModelOwner"},{"location":"api/vector/com.haroldadmin.vector/androidx.activity.-component-activity/view-model/","text":"vector / com.haroldadmin.vector / androidx.activity.ComponentActivity / viewModel viewModel \u00b6 inline fun <reified VM : VectorViewModel < S >, reified S : VectorState > ComponentActivity .viewModel(stateStoreContext: CoroutineContext = Dispatchers.Default + Job()): vectorLazy < VM > Lazy delegate for creating a VectorViewModel from an Activity Creates and returns the requested VectorViewModel automatically using reflection. The returned ViewModel is scoped to this activity Parameters \u00b6 VM - The type of the VectorViewModel being requested S - The type of State class bound to the requested ViewModel stateStoreContext - The CoroutineContext to be used in the ViewModel's state store inline fun <reified VM : VectorViewModel < S >, reified S : VectorState > ComponentActivity .viewModel(noinline viewModelCreator: (initialState: S , handle: SavedStateHandle ) -> VM ): vectorLazy < VM > Lazy delegate for creating a VectorViewModel from an Activity using the given producer lambda Creates and returns the requested VectorViewModel automatically using reflection. The returned ViewModel is scoped to this activity. Parameters \u00b6 VM - The type of the VectorViewModel being requested S - The type of State class bound to the requested ViewModel viewModelCreator - The lambda which creates and returns the requested ViewModel","title":"View model"},{"location":"api/vector/com.haroldadmin.vector/androidx.activity.-component-activity/view-model/#viewmodel","text":"inline fun <reified VM : VectorViewModel < S >, reified S : VectorState > ComponentActivity .viewModel(stateStoreContext: CoroutineContext = Dispatchers.Default + Job()): vectorLazy < VM > Lazy delegate for creating a VectorViewModel from an Activity Creates and returns the requested VectorViewModel automatically using reflection. The returned ViewModel is scoped to this activity","title":"viewModel"},{"location":"api/vector/com.haroldadmin.vector/androidx.activity.-component-activity/view-model/#parameters","text":"VM - The type of the VectorViewModel being requested S - The type of State class bound to the requested ViewModel stateStoreContext - The CoroutineContext to be used in the ViewModel's state store inline fun <reified VM : VectorViewModel < S >, reified S : VectorState > ComponentActivity .viewModel(noinline viewModelCreator: (initialState: S , handle: SavedStateHandle ) -> VM ): vectorLazy < VM > Lazy delegate for creating a VectorViewModel from an Activity using the given producer lambda Creates and returns the requested VectorViewModel automatically using reflection. The returned ViewModel is scoped to this activity.","title":"Parameters"},{"location":"api/vector/com.haroldadmin.vector/androidx.activity.-component-activity/view-model/#parameters_1","text":"VM - The type of the VectorViewModel being requested S - The type of State class bound to the requested ViewModel viewModelCreator - The lambda which creates and returns the requested ViewModel","title":"Parameters"},{"location":"api/vector/com.haroldadmin.vector/androidx.fragment.app.-fragment/","text":"vector / com.haroldadmin.vector / androidx.fragment.app.Fragment Extensions for androidx.fragment.app.Fragment \u00b6 Name Summary activityViewModel fun <VM : VectorViewModel < S >, S : VectorState > Fragment .activityViewModel(stateStoreContext: CoroutineContext = Dispatchers.Default + Job()): vectorLazy < VM > Lazy delegate for creating an activity scoped VectorViewModel from a Fragment. Creates and returns the requested VectorViewModel automatically using reflection. The returned ViewModel is scoped to this Fragment's parent activity. fun <VM : VectorViewModel < S >, S : VectorState > Fragment .activityViewModel(viewModelCreator: (initialState: S , handle: SavedStateHandle ) -> VM ): vectorLazy < VM > Lazy delegate for creating a parent activity scoped VectorViewModel from a Fragment using the given producer lambda activityViewModelOwner fun Fragment .activityViewModelOwner(): ActivityViewModelOwner Creates a ViewModelOwner from the parent activity of this Fragment fragmentViewModel fun <VM : VectorViewModel < S >, S : VectorState > Fragment .fragmentViewModel(stateStoreContext: CoroutineContext = Dispatchers.Default + Job()): vectorLazy < VM > Lazy delegate for creating a VectorViewModel from a Fragment fun <VM : VectorViewModel < S >, S : VectorState > Fragment .fragmentViewModel(viewModelCreator: (initialState: S , handle: SavedStateHandle ) -> VM ): vectorLazy < VM > Lazy delegate for creating a VectorViewModel from a Fragment using the given producer lambda fragmentViewModelOwner fun Fragment .fragmentViewModelOwner(): FragmentViewModelOwner Creates a ViewModelOwner from this Fragment","title":"Home"},{"location":"api/vector/com.haroldadmin.vector/androidx.fragment.app.-fragment/#extensions-for-androidxfragmentappfragment","text":"Name Summary activityViewModel fun <VM : VectorViewModel < S >, S : VectorState > Fragment .activityViewModel(stateStoreContext: CoroutineContext = Dispatchers.Default + Job()): vectorLazy < VM > Lazy delegate for creating an activity scoped VectorViewModel from a Fragment. Creates and returns the requested VectorViewModel automatically using reflection. The returned ViewModel is scoped to this Fragment's parent activity. fun <VM : VectorViewModel < S >, S : VectorState > Fragment .activityViewModel(viewModelCreator: (initialState: S , handle: SavedStateHandle ) -> VM ): vectorLazy < VM > Lazy delegate for creating a parent activity scoped VectorViewModel from a Fragment using the given producer lambda activityViewModelOwner fun Fragment .activityViewModelOwner(): ActivityViewModelOwner Creates a ViewModelOwner from the parent activity of this Fragment fragmentViewModel fun <VM : VectorViewModel < S >, S : VectorState > Fragment .fragmentViewModel(stateStoreContext: CoroutineContext = Dispatchers.Default + Job()): vectorLazy < VM > Lazy delegate for creating a VectorViewModel from a Fragment fun <VM : VectorViewModel < S >, S : VectorState > Fragment .fragmentViewModel(viewModelCreator: (initialState: S , handle: SavedStateHandle ) -> VM ): vectorLazy < VM > Lazy delegate for creating a VectorViewModel from a Fragment using the given producer lambda fragmentViewModelOwner fun Fragment .fragmentViewModelOwner(): FragmentViewModelOwner Creates a ViewModelOwner from this Fragment","title":"Extensions for androidx.fragment.app.Fragment"},{"location":"api/vector/com.haroldadmin.vector/androidx.fragment.app.-fragment/activity-view-model-owner/","text":"vector / com.haroldadmin.vector / androidx.fragment.app.Fragment / activityViewModelOwner activityViewModelOwner \u00b6 fun Fragment .activityViewModelOwner(): ActivityViewModelOwner Creates a ViewModelOwner from the parent activity of this Fragment","title":"Activity view model owner"},{"location":"api/vector/com.haroldadmin.vector/androidx.fragment.app.-fragment/activity-view-model-owner/#activityviewmodelowner","text":"fun Fragment .activityViewModelOwner(): ActivityViewModelOwner Creates a ViewModelOwner from the parent activity of this Fragment","title":"activityViewModelOwner"},{"location":"api/vector/com.haroldadmin.vector/androidx.fragment.app.-fragment/activity-view-model/","text":"vector / com.haroldadmin.vector / androidx.fragment.app.Fragment / activityViewModel activityViewModel \u00b6 inline fun <reified VM : VectorViewModel < S >, reified S : VectorState > Fragment .activityViewModel(stateStoreContext: CoroutineContext = Dispatchers.Default + Job()): vectorLazy < VM > Lazy delegate for creating an activity scoped VectorViewModel from a Fragment. Creates and returns the requested VectorViewModel automatically using reflection. The returned ViewModel is scoped to this Fragment's parent activity. Parameters \u00b6 VM - The type of the VectorViewModel being requested S - The type of State class bound to the requested ViewModel stateStoreContext - The CoroutineContext to be used in the ViewModel's state store inline fun <reified VM : VectorViewModel < S >, reified S : VectorState > Fragment .activityViewModel(noinline viewModelCreator: (initialState: S , handle: SavedStateHandle ) -> VM ): vectorLazy < VM > Lazy delegate for creating a parent activity scoped VectorViewModel from a Fragment using the given producer lambda Creates and returns the requested VectorViewModel automatically using reflection. The returned ViewModel is scoped to this Fragment's parent activity. Parameters \u00b6 VM - The type of the VectorViewModel being requested S - The type of State class bound to the requested ViewModel viewModelCreator - The lambda which creates and returns the requested ViewModel","title":"Activity view model"},{"location":"api/vector/com.haroldadmin.vector/androidx.fragment.app.-fragment/activity-view-model/#activityviewmodel","text":"inline fun <reified VM : VectorViewModel < S >, reified S : VectorState > Fragment .activityViewModel(stateStoreContext: CoroutineContext = Dispatchers.Default + Job()): vectorLazy < VM > Lazy delegate for creating an activity scoped VectorViewModel from a Fragment. Creates and returns the requested VectorViewModel automatically using reflection. The returned ViewModel is scoped to this Fragment's parent activity.","title":"activityViewModel"},{"location":"api/vector/com.haroldadmin.vector/androidx.fragment.app.-fragment/activity-view-model/#parameters","text":"VM - The type of the VectorViewModel being requested S - The type of State class bound to the requested ViewModel stateStoreContext - The CoroutineContext to be used in the ViewModel's state store inline fun <reified VM : VectorViewModel < S >, reified S : VectorState > Fragment .activityViewModel(noinline viewModelCreator: (initialState: S , handle: SavedStateHandle ) -> VM ): vectorLazy < VM > Lazy delegate for creating a parent activity scoped VectorViewModel from a Fragment using the given producer lambda Creates and returns the requested VectorViewModel automatically using reflection. The returned ViewModel is scoped to this Fragment's parent activity.","title":"Parameters"},{"location":"api/vector/com.haroldadmin.vector/androidx.fragment.app.-fragment/activity-view-model/#parameters_1","text":"VM - The type of the VectorViewModel being requested S - The type of State class bound to the requested ViewModel viewModelCreator - The lambda which creates and returns the requested ViewModel","title":"Parameters"},{"location":"api/vector/com.haroldadmin.vector/androidx.fragment.app.-fragment/fragment-view-model-owner/","text":"vector / com.haroldadmin.vector / androidx.fragment.app.Fragment / fragmentViewModelOwner fragmentViewModelOwner \u00b6 fun Fragment .fragmentViewModelOwner(): FragmentViewModelOwner Creates a ViewModelOwner from this Fragment","title":"Fragment view model owner"},{"location":"api/vector/com.haroldadmin.vector/androidx.fragment.app.-fragment/fragment-view-model-owner/#fragmentviewmodelowner","text":"fun Fragment .fragmentViewModelOwner(): FragmentViewModelOwner Creates a ViewModelOwner from this Fragment","title":"fragmentViewModelOwner"},{"location":"api/vector/com.haroldadmin.vector/androidx.fragment.app.-fragment/fragment-view-model/","text":"vector / com.haroldadmin.vector / androidx.fragment.app.Fragment / fragmentViewModel fragmentViewModel \u00b6 inline fun <reified VM : VectorViewModel < S >, reified S : VectorState > Fragment .fragmentViewModel(stateStoreContext: CoroutineContext = Dispatchers.Default + Job()): vectorLazy < VM > Lazy delegate for creating a VectorViewModel from a Fragment Creates and returns the requested VectorViewModel automatically using reflection. The returned ViewModel is scoped to this Fragment. Parameters \u00b6 VM - The type of the VectorViewModel being requested S - The type of State class bound to the requested ViewModel stateStoreContext - The CoroutineContext to be used in the ViewModel's state store inline fun <reified VM : VectorViewModel < S >, reified S : VectorState > Fragment .fragmentViewModel(noinline viewModelCreator: (initialState: S , handle: SavedStateHandle ) -> VM ): vectorLazy < VM > Lazy delegate for creating a VectorViewModel from a Fragment using the given producer lambda Creates and returns the requested VectorViewModel automatically using reflection. The returned ViewModel is scoped to this Fragment. Parameters \u00b6 VM - The type of the VectorViewModel being requested S - The type of State class bound to the requested ViewModel viewModelCreator - The lambda which creates and returns the requested ViewModel","title":"Fragment view model"},{"location":"api/vector/com.haroldadmin.vector/androidx.fragment.app.-fragment/fragment-view-model/#fragmentviewmodel","text":"inline fun <reified VM : VectorViewModel < S >, reified S : VectorState > Fragment .fragmentViewModel(stateStoreContext: CoroutineContext = Dispatchers.Default + Job()): vectorLazy < VM > Lazy delegate for creating a VectorViewModel from a Fragment Creates and returns the requested VectorViewModel automatically using reflection. The returned ViewModel is scoped to this Fragment.","title":"fragmentViewModel"},{"location":"api/vector/com.haroldadmin.vector/androidx.fragment.app.-fragment/fragment-view-model/#parameters","text":"VM - The type of the VectorViewModel being requested S - The type of State class bound to the requested ViewModel stateStoreContext - The CoroutineContext to be used in the ViewModel's state store inline fun <reified VM : VectorViewModel < S >, reified S : VectorState > Fragment .fragmentViewModel(noinline viewModelCreator: (initialState: S , handle: SavedStateHandle ) -> VM ): vectorLazy < VM > Lazy delegate for creating a VectorViewModel from a Fragment using the given producer lambda Creates and returns the requested VectorViewModel automatically using reflection. The returned ViewModel is scoped to this Fragment.","title":"Parameters"},{"location":"api/vector/com.haroldadmin.vector/androidx.fragment.app.-fragment/fragment-view-model/#parameters_1","text":"VM - The type of the VectorViewModel being requested S - The type of State class bound to the requested ViewModel viewModelCreator - The lambda which creates and returns the requested ViewModel","title":"Parameters"},{"location":"api/vector/com.haroldadmin.vector/vector-lazy/","text":"vector / com.haroldadmin.vector / vectorLazy vectorLazy \u00b6 class vectorLazy<out T> : Lazy < T > A lazy delegate class, which takes in an initializer to initialize its underlying property. Implements the double-checked locking algorithm. Constructors \u00b6 Name Summary <init> vectorLazy(initializer: () -> T ) A lazy delegate class, which takes in an initializer to initialize its underlying property. Implements the double-checked locking algorithm. Properties \u00b6 Name Summary value val value: T Functions \u00b6 Name Summary isInitialized fun isInitialized(): Boolean","title":"Home"},{"location":"api/vector/com.haroldadmin.vector/vector-lazy/#vectorlazy","text":"class vectorLazy<out T> : Lazy < T > A lazy delegate class, which takes in an initializer to initialize its underlying property. Implements the double-checked locking algorithm.","title":"vectorLazy"},{"location":"api/vector/com.haroldadmin.vector/vector-lazy/#constructors","text":"Name Summary <init> vectorLazy(initializer: () -> T ) A lazy delegate class, which takes in an initializer to initialize its underlying property. Implements the double-checked locking algorithm.","title":"Constructors"},{"location":"api/vector/com.haroldadmin.vector/vector-lazy/#properties","text":"Name Summary value val value: T","title":"Properties"},{"location":"api/vector/com.haroldadmin.vector/vector-lazy/#functions","text":"Name Summary isInitialized fun isInitialized(): Boolean","title":"Functions"},{"location":"api/vector/com.haroldadmin.vector/vector-lazy/-init-/","text":"vector / com.haroldadmin.vector / vectorLazy / <init> <init> \u00b6 vectorLazy(initializer: () -> T ) A lazy delegate class, which takes in an initializer to initialize its underlying property. Implements the double-checked locking algorithm.","title":" init "},{"location":"api/vector/com.haroldadmin.vector/vector-lazy/-init-/#init","text":"vectorLazy(initializer: () -> T ) A lazy delegate class, which takes in an initializer to initialize its underlying property. Implements the double-checked locking algorithm.","title":"&lt;init&gt;"},{"location":"api/vector/com.haroldadmin.vector/vector-lazy/is-initialized/","text":"vector / com.haroldadmin.vector / vectorLazy / isInitialized isInitialized \u00b6 fun isInitialized(): Boolean","title":"Is initialized"},{"location":"api/vector/com.haroldadmin.vector/vector-lazy/is-initialized/#isinitialized","text":"fun isInitialized(): Boolean","title":"isInitialized"},{"location":"api/vector/com.haroldadmin.vector/vector-lazy/value/","text":"vector / com.haroldadmin.vector / vectorLazy / value value \u00b6 val value: T","title":"Value"},{"location":"api/vector/com.haroldadmin.vector/vector-lazy/value/#value","text":"val value: T","title":"value"},{"location":"api/vector/com.haroldadmin.vector.loggers/","text":"vector / com.haroldadmin.vector.loggers Package com.haroldadmin.vector.loggers \u00b6 Types \u00b6 Name Summary Logger interface Logger Used to write debug logs. Functions \u00b6 Name Summary androidLogger fun androidLogger(tag: String ): Logger A utility function to create instances of AndroidLogger logd fun Logger .logd(messageProducer: () -> String ): Unit logv fun Logger .logv(messageProducer: () -> String ): Unit systemOutLogger fun systemOutLogger(tag: String = \"Vector\"): Logger","title":"Home"},{"location":"api/vector/com.haroldadmin.vector.loggers/#package-comharoldadminvectorloggers","text":"","title":"Package com.haroldadmin.vector.loggers"},{"location":"api/vector/com.haroldadmin.vector.loggers/#types","text":"Name Summary Logger interface Logger Used to write debug logs.","title":"Types"},{"location":"api/vector/com.haroldadmin.vector.loggers/#functions","text":"Name Summary androidLogger fun androidLogger(tag: String ): Logger A utility function to create instances of AndroidLogger logd fun Logger .logd(messageProducer: () -> String ): Unit logv fun Logger .logv(messageProducer: () -> String ): Unit systemOutLogger fun systemOutLogger(tag: String = \"Vector\"): Logger","title":"Functions"},{"location":"api/vector/com.haroldadmin.vector.loggers/android-logger/","text":"vector / com.haroldadmin.vector.loggers / androidLogger androidLogger \u00b6 fun androidLogger(tag: String ): Logger A utility function to create instances of AndroidLogger","title":"Android logger"},{"location":"api/vector/com.haroldadmin.vector.loggers/android-logger/#androidlogger","text":"fun androidLogger(tag: String ): Logger A utility function to create instances of AndroidLogger","title":"androidLogger"},{"location":"api/vector/com.haroldadmin.vector.loggers/logd/","text":"vector / com.haroldadmin.vector.loggers / logd logd \u00b6 inline fun Logger .logd(crossinline messageProducer: () -> String ): Unit","title":"Logd"},{"location":"api/vector/com.haroldadmin.vector.loggers/logd/#logd","text":"inline fun Logger .logd(crossinline messageProducer: () -> String ): Unit","title":"logd"},{"location":"api/vector/com.haroldadmin.vector.loggers/logv/","text":"vector / com.haroldadmin.vector.loggers / logv logv \u00b6 inline fun Logger .logv(crossinline messageProducer: () -> String ): Unit","title":"Logv"},{"location":"api/vector/com.haroldadmin.vector.loggers/logv/#logv","text":"inline fun Logger .logv(crossinline messageProducer: () -> String ): Unit","title":"logv"},{"location":"api/vector/com.haroldadmin.vector.loggers/system-out-logger/","text":"vector / com.haroldadmin.vector.loggers / systemOutLogger systemOutLogger \u00b6 fun systemOutLogger(tag: String = \"Vector\"): Logger","title":"System out logger"},{"location":"api/vector/com.haroldadmin.vector.loggers/system-out-logger/#systemoutlogger","text":"fun systemOutLogger(tag: String = \"Vector\"): Logger","title":"systemOutLogger"},{"location":"api/vector/com.haroldadmin.vector.loggers/-logger/","text":"vector / com.haroldadmin.vector.loggers / Logger Logger \u00b6 interface Logger Used to write debug logs. Implementations of this interface can be used to provide different output sources for log statements, such as Android's built in Logging class, or STDOUT. Types \u00b6 Name Summary Level enum class Level Properties \u00b6 Name Summary tag abstract val tag: String A name tag associated with this logger for identification and filtering Functions \u00b6 Name Summary log abstract fun log(message: String , level: Logger.Level = Level.DEBUG): Unit Logs the given message to the associated output Extension Functions \u00b6 Name Summary logd fun Logger .logd(messageProducer: () -> String ): Unit logv fun Logger .logv(messageProducer: () -> String ): Unit","title":"Home"},{"location":"api/vector/com.haroldadmin.vector.loggers/-logger/#logger","text":"interface Logger Used to write debug logs. Implementations of this interface can be used to provide different output sources for log statements, such as Android's built in Logging class, or STDOUT.","title":"Logger"},{"location":"api/vector/com.haroldadmin.vector.loggers/-logger/#types","text":"Name Summary Level enum class Level","title":"Types"},{"location":"api/vector/com.haroldadmin.vector.loggers/-logger/#properties","text":"Name Summary tag abstract val tag: String A name tag associated with this logger for identification and filtering","title":"Properties"},{"location":"api/vector/com.haroldadmin.vector.loggers/-logger/#functions","text":"Name Summary log abstract fun log(message: String , level: Logger.Level = Level.DEBUG): Unit Logs the given message to the associated output","title":"Functions"},{"location":"api/vector/com.haroldadmin.vector.loggers/-logger/#extension-functions","text":"Name Summary logd fun Logger .logd(messageProducer: () -> String ): Unit logv fun Logger .logv(messageProducer: () -> String ): Unit","title":"Extension Functions"},{"location":"api/vector/com.haroldadmin.vector.loggers/-logger/log/","text":"vector / com.haroldadmin.vector.loggers / Logger / log log \u00b6 abstract fun log(message: String , level: Logger.Level = Level.DEBUG): Unit Logs the given message to the associated output Parameters \u00b6 message - The message to be logged","title":"Log"},{"location":"api/vector/com.haroldadmin.vector.loggers/-logger/log/#log","text":"abstract fun log(message: String , level: Logger.Level = Level.DEBUG): Unit Logs the given message to the associated output","title":"log"},{"location":"api/vector/com.haroldadmin.vector.loggers/-logger/log/#parameters","text":"message - The message to be logged","title":"Parameters"},{"location":"api/vector/com.haroldadmin.vector.loggers/-logger/tag/","text":"vector / com.haroldadmin.vector.loggers / Logger / tag tag \u00b6 abstract val tag: String A name tag associated with this logger for identification and filtering","title":"Tag"},{"location":"api/vector/com.haroldadmin.vector.loggers/-logger/tag/#tag","text":"abstract val tag: String A name tag associated with this logger for identification and filtering","title":"tag"},{"location":"api/vector/com.haroldadmin.vector.loggers/-logger/-level/","text":"vector / com.haroldadmin.vector.loggers / Logger / Level Level \u00b6 enum class Level Enum Values \u00b6 Name Summary DEBUG VERBOSE","title":"Home"},{"location":"api/vector/com.haroldadmin.vector.loggers/-logger/-level/#level","text":"enum class Level","title":"Level"},{"location":"api/vector/com.haroldadmin.vector.loggers/-logger/-level/#enum-values","text":"Name Summary DEBUG VERBOSE","title":"Enum Values"},{"location":"api/vector/com.haroldadmin.vector.loggers/-logger/-level/-d-e-b-u-g/","text":"vector / com.haroldadmin.vector.loggers / Logger / Level / DEBUG DEBUG \u00b6 DEBUG","title":" d e b u g"},{"location":"api/vector/com.haroldadmin.vector.loggers/-logger/-level/-d-e-b-u-g/#debug","text":"DEBUG","title":"DEBUG"},{"location":"api/vector/com.haroldadmin.vector.loggers/-logger/-level/-v-e-r-b-o-s-e/","text":"vector / com.haroldadmin.vector.loggers / Logger / Level / VERBOSE VERBOSE \u00b6 VERBOSE","title":" v e r b o s e"},{"location":"api/vector/com.haroldadmin.vector.loggers/-logger/-level/-v-e-r-b-o-s-e/#verbose","text":"VERBOSE","title":"VERBOSE"},{"location":"api/vector/com.haroldadmin.vector.state/","text":"vector / com.haroldadmin.vector.state Package com.haroldadmin.vector.state \u00b6 Types \u00b6 Name Summary StateHolder interface StateHolder<S : VectorState > Holds the current state value and provides access to it. A ConflatedBroadcastChannel is used to hold the current state value. clear should be called when this state holder is no longer in use. StateProcessor interface StateProcessor<S : VectorState > : CoroutineScope An entity that manages any Action on state. StateStore abstract class StateStore<S : VectorState > : StateHolder < S >, StateProcessor < S > A class which can hold current state as well as handle actions to be performed on it.","title":"Home"},{"location":"api/vector/com.haroldadmin.vector.state/#package-comharoldadminvectorstate","text":"","title":"Package com.haroldadmin.vector.state"},{"location":"api/vector/com.haroldadmin.vector.state/#types","text":"Name Summary StateHolder interface StateHolder<S : VectorState > Holds the current state value and provides access to it. A ConflatedBroadcastChannel is used to hold the current state value. clear should be called when this state holder is no longer in use. StateProcessor interface StateProcessor<S : VectorState > : CoroutineScope An entity that manages any Action on state. StateStore abstract class StateStore<S : VectorState > : StateHolder < S >, StateProcessor < S > A class which can hold current state as well as handle actions to be performed on it.","title":"Types"},{"location":"api/vector/com.haroldadmin.vector.state/-state-holder/","text":"vector / com.haroldadmin.vector.state / StateHolder StateHolder \u00b6 interface StateHolder<S : VectorState > Holds the current state value and provides access to it. A ConflatedBroadcastChannel is used to hold the current state value. clear should be called when this state holder is no longer in use. Parameters \u00b6 S - The state type implementing VectorState Properties \u00b6 Name Summary state open val state: S A convenient way to access the current state value in the stateObservable stateObservable abstract val stateObservable: ConflatedBroadcastChannel< S > A ConflatedBroadcastChannel to expose the state as an observable entity. This channel is conflated, so only the latest state value is present in it Functions \u00b6 Name Summary clearHolder abstract fun clearHolder(): Unit This method is expected to be called when this state holder is no longer being used Inheritors \u00b6 Name Summary StateStore abstract class StateStore<S : VectorState > : StateHolder < S >, StateProcessor < S > A class which can hold current state as well as handle actions to be performed on it.","title":"Home"},{"location":"api/vector/com.haroldadmin.vector.state/-state-holder/#stateholder","text":"interface StateHolder<S : VectorState > Holds the current state value and provides access to it. A ConflatedBroadcastChannel is used to hold the current state value. clear should be called when this state holder is no longer in use.","title":"StateHolder"},{"location":"api/vector/com.haroldadmin.vector.state/-state-holder/#parameters","text":"S - The state type implementing VectorState","title":"Parameters"},{"location":"api/vector/com.haroldadmin.vector.state/-state-holder/#properties","text":"Name Summary state open val state: S A convenient way to access the current state value in the stateObservable stateObservable abstract val stateObservable: ConflatedBroadcastChannel< S > A ConflatedBroadcastChannel to expose the state as an observable entity. This channel is conflated, so only the latest state value is present in it","title":"Properties"},{"location":"api/vector/com.haroldadmin.vector.state/-state-holder/#functions","text":"Name Summary clearHolder abstract fun clearHolder(): Unit This method is expected to be called when this state holder is no longer being used","title":"Functions"},{"location":"api/vector/com.haroldadmin.vector.state/-state-holder/#inheritors","text":"Name Summary StateStore abstract class StateStore<S : VectorState > : StateHolder < S >, StateProcessor < S > A class which can hold current state as well as handle actions to be performed on it.","title":"Inheritors"},{"location":"api/vector/com.haroldadmin.vector.state/-state-holder/clear-holder/","text":"vector / com.haroldadmin.vector.state / StateHolder / clearHolder clearHolder \u00b6 abstract fun clearHolder(): Unit This method is expected to be called when this state holder is no longer being used","title":"Clear holder"},{"location":"api/vector/com.haroldadmin.vector.state/-state-holder/clear-holder/#clearholder","text":"abstract fun clearHolder(): Unit This method is expected to be called when this state holder is no longer being used","title":"clearHolder"},{"location":"api/vector/com.haroldadmin.vector.state/-state-holder/state-observable/","text":"vector / com.haroldadmin.vector.state / StateHolder / stateObservable stateObservable \u00b6 abstract val stateObservable: ConflatedBroadcastChannel< S > A ConflatedBroadcastChannel to expose the state as an observable entity. This channel is conflated, so only the latest state value is present in it","title":"State observable"},{"location":"api/vector/com.haroldadmin.vector.state/-state-holder/state-observable/#stateobservable","text":"abstract val stateObservable: ConflatedBroadcastChannel< S > A ConflatedBroadcastChannel to expose the state as an observable entity. This channel is conflated, so only the latest state value is present in it","title":"stateObservable"},{"location":"api/vector/com.haroldadmin.vector.state/-state-holder/state/","text":"vector / com.haroldadmin.vector.state / StateHolder / state state \u00b6 open val state: S A convenient way to access the current state value in the stateObservable","title":"State"},{"location":"api/vector/com.haroldadmin.vector.state/-state-holder/state/#state","text":"open val state: S A convenient way to access the current state value in the stateObservable","title":"state"},{"location":"api/vector/com.haroldadmin.vector.state/-state-processor/","text":"vector / com.haroldadmin.vector.state / StateProcessor StateProcessor \u00b6 interface StateProcessor<S : VectorState > : CoroutineScope An entity that manages any Action on state. Parameters \u00b6 S - The state type implementing VectorState A SetStateAction is be processed before any existing GetStateAction in the queue A GetStateAction is given the latest state value as it's parameter Functions \u00b6 Name Summary clearProcessor abstract fun clearProcessor(): Unit Cleanup any resources held by this processor. offerGetAction abstract fun offerGetAction(action: suspend ( S ) -> Unit ): Unit Offer a GetStateAction to this processor. This action will be processed after any existing GetStateAction current waiting in this processor. The state parameter supplied to this action shall be the latest state value at the time of processing this action. offerSetAction abstract fun offerSetAction(reducer: suspend S .() -> S ): Unit Offer a SetStateAction to this processor. This action will be processed as soon as possible, before all existing GetStateAction , if any. Inheritors \u00b6 Name Summary StateStore abstract class StateStore<S : VectorState > : StateHolder < S >, StateProcessor < S > A class which can hold current state as well as handle actions to be performed on it.","title":"Home"},{"location":"api/vector/com.haroldadmin.vector.state/-state-processor/#stateprocessor","text":"interface StateProcessor<S : VectorState > : CoroutineScope An entity that manages any Action on state.","title":"StateProcessor"},{"location":"api/vector/com.haroldadmin.vector.state/-state-processor/#parameters","text":"S - The state type implementing VectorState A SetStateAction is be processed before any existing GetStateAction in the queue A GetStateAction is given the latest state value as it's parameter","title":"Parameters"},{"location":"api/vector/com.haroldadmin.vector.state/-state-processor/#functions","text":"Name Summary clearProcessor abstract fun clearProcessor(): Unit Cleanup any resources held by this processor. offerGetAction abstract fun offerGetAction(action: suspend ( S ) -> Unit ): Unit Offer a GetStateAction to this processor. This action will be processed after any existing GetStateAction current waiting in this processor. The state parameter supplied to this action shall be the latest state value at the time of processing this action. offerSetAction abstract fun offerSetAction(reducer: suspend S .() -> S ): Unit Offer a SetStateAction to this processor. This action will be processed as soon as possible, before all existing GetStateAction , if any.","title":"Functions"},{"location":"api/vector/com.haroldadmin.vector.state/-state-processor/#inheritors","text":"Name Summary StateStore abstract class StateStore<S : VectorState > : StateHolder < S >, StateProcessor < S > A class which can hold current state as well as handle actions to be performed on it.","title":"Inheritors"},{"location":"api/vector/com.haroldadmin.vector.state/-state-processor/clear-processor/","text":"vector / com.haroldadmin.vector.state / StateProcessor / clearProcessor clearProcessor \u00b6 abstract fun clearProcessor(): Unit Cleanup any resources held by this processor.","title":"Clear processor"},{"location":"api/vector/com.haroldadmin.vector.state/-state-processor/clear-processor/#clearprocessor","text":"abstract fun clearProcessor(): Unit Cleanup any resources held by this processor.","title":"clearProcessor"},{"location":"api/vector/com.haroldadmin.vector.state/-state-processor/offer-get-action/","text":"vector / com.haroldadmin.vector.state / StateProcessor / offerGetAction offerGetAction \u00b6 abstract fun offerGetAction(action: suspend ( S ) -> Unit ): Unit Offer a GetStateAction to this processor. This action will be processed after any existing GetStateAction current waiting in this processor. The state parameter supplied to this action shall be the latest state value at the time of processing this action.","title":"Offer get action"},{"location":"api/vector/com.haroldadmin.vector.state/-state-processor/offer-get-action/#offergetaction","text":"abstract fun offerGetAction(action: suspend ( S ) -> Unit ): Unit Offer a GetStateAction to this processor. This action will be processed after any existing GetStateAction current waiting in this processor. The state parameter supplied to this action shall be the latest state value at the time of processing this action.","title":"offerGetAction"},{"location":"api/vector/com.haroldadmin.vector.state/-state-processor/offer-set-action/","text":"vector / com.haroldadmin.vector.state / StateProcessor / offerSetAction offerSetAction \u00b6 abstract fun offerSetAction(reducer: suspend S .() -> S ): Unit Offer a SetStateAction to this processor. This action will be processed as soon as possible, before all existing GetStateAction , if any. Parameters \u00b6 reducer - The action to be offered","title":"Offer set action"},{"location":"api/vector/com.haroldadmin.vector.state/-state-processor/offer-set-action/#offersetaction","text":"abstract fun offerSetAction(reducer: suspend S .() -> S ): Unit Offer a SetStateAction to this processor. This action will be processed as soon as possible, before all existing GetStateAction , if any.","title":"offerSetAction"},{"location":"api/vector/com.haroldadmin.vector.state/-state-processor/offer-set-action/#parameters","text":"reducer - The action to be offered","title":"Parameters"},{"location":"api/vector/com.haroldadmin.vector.state/-state-store/","text":"vector / com.haroldadmin.vector.state / StateStore StateStore \u00b6 abstract class StateStore<S : VectorState > : StateHolder < S >, StateProcessor < S > A class which can hold current state as well as handle actions to be performed on it. Parameters \u00b6 stateHolder - The delegate to handle StateHolder functions stateProcessor - The delegate to handle StateProcessor functions Constructors \u00b6 Name Summary <init> StateStore(stateHolder: StateHolder < S >, stateProcessor: StateProcessor < S >) A class which can hold current state as well as handle actions to be performed on it. Properties \u00b6 Name Summary stateHolder open val stateHolder: StateHolder < S > The delegate to handle StateHolder functions stateProcessor open val stateProcessor: StateProcessor < S > The delegate to handle StateProcessor functions Functions \u00b6 Name Summary clear abstract fun clear(): Unit Clear any resources held by this state store. Implementations should also forward the call to stateHolder and stateProcessor","title":"Home"},{"location":"api/vector/com.haroldadmin.vector.state/-state-store/#statestore","text":"abstract class StateStore<S : VectorState > : StateHolder < S >, StateProcessor < S > A class which can hold current state as well as handle actions to be performed on it.","title":"StateStore"},{"location":"api/vector/com.haroldadmin.vector.state/-state-store/#parameters","text":"stateHolder - The delegate to handle StateHolder functions stateProcessor - The delegate to handle StateProcessor functions","title":"Parameters"},{"location":"api/vector/com.haroldadmin.vector.state/-state-store/#constructors","text":"Name Summary <init> StateStore(stateHolder: StateHolder < S >, stateProcessor: StateProcessor < S >) A class which can hold current state as well as handle actions to be performed on it.","title":"Constructors"},{"location":"api/vector/com.haroldadmin.vector.state/-state-store/#properties","text":"Name Summary stateHolder open val stateHolder: StateHolder < S > The delegate to handle StateHolder functions stateProcessor open val stateProcessor: StateProcessor < S > The delegate to handle StateProcessor functions","title":"Properties"},{"location":"api/vector/com.haroldadmin.vector.state/-state-store/#functions","text":"Name Summary clear abstract fun clear(): Unit Clear any resources held by this state store. Implementations should also forward the call to stateHolder and stateProcessor","title":"Functions"},{"location":"api/vector/com.haroldadmin.vector.state/-state-store/-init-/","text":"vector / com.haroldadmin.vector.state / StateStore / <init> <init> \u00b6 StateStore(stateHolder: StateHolder < S >, stateProcessor: StateProcessor < S >) A class which can hold current state as well as handle actions to be performed on it. Parameters \u00b6 stateHolder - The delegate to handle StateHolder functions stateProcessor - The delegate to handle StateProcessor functions","title":" init "},{"location":"api/vector/com.haroldadmin.vector.state/-state-store/-init-/#init","text":"StateStore(stateHolder: StateHolder < S >, stateProcessor: StateProcessor < S >) A class which can hold current state as well as handle actions to be performed on it.","title":"&lt;init&gt;"},{"location":"api/vector/com.haroldadmin.vector.state/-state-store/-init-/#parameters","text":"stateHolder - The delegate to handle StateHolder functions stateProcessor - The delegate to handle StateProcessor functions","title":"Parameters"},{"location":"api/vector/com.haroldadmin.vector.state/-state-store/clear/","text":"vector / com.haroldadmin.vector.state / StateStore / clear clear \u00b6 abstract fun clear(): Unit Clear any resources held by this state store. Implementations should also forward the call to stateHolder and stateProcessor","title":"Clear"},{"location":"api/vector/com.haroldadmin.vector.state/-state-store/clear/#clear","text":"abstract fun clear(): Unit Clear any resources held by this state store. Implementations should also forward the call to stateHolder and stateProcessor","title":"clear"},{"location":"api/vector/com.haroldadmin.vector.state/-state-store/state-holder/","text":"vector / com.haroldadmin.vector.state / StateStore / stateHolder stateHolder \u00b6 protected open val stateHolder: StateHolder < S > The delegate to handle StateHolder functions","title":"State holder"},{"location":"api/vector/com.haroldadmin.vector.state/-state-store/state-holder/#stateholder","text":"protected open val stateHolder: StateHolder < S > The delegate to handle StateHolder functions","title":"stateHolder"},{"location":"api/vector/com.haroldadmin.vector.state/-state-store/state-processor/","text":"vector / com.haroldadmin.vector.state / StateStore / stateProcessor stateProcessor \u00b6 protected open val stateProcessor: StateProcessor < S > The delegate to handle StateProcessor functions","title":"State processor"},{"location":"api/vector/com.haroldadmin.vector.state/-state-store/state-processor/#stateprocessor","text":"protected open val stateProcessor: StateProcessor < S > The delegate to handle StateProcessor functions","title":"stateProcessor"},{"location":"components/logging/","text":"Logging \u00b6 Vector can log state related actions. It ships with two different loggers: AndroidLogger: Writes log statements to Android log ( Log.* ). Can be created using the androidLogger() factory function. SystemOutLogger: Writes log statements to STDOUT ( println ). Can be created using the systemOutLogger() factory function. By default, the AndroidLogger is used, but you can customize which ever one you want based on your needs. The Logger interface is very simple, and you can use it to create your custom implementations as well. Enable/Disable Logging \u00b6 You can enable or disable logging by setting Vector.enableLogging .","title":"Logging"},{"location":"components/logging/#logging","text":"Vector can log state related actions. It ships with two different loggers: AndroidLogger: Writes log statements to Android log ( Log.* ). Can be created using the androidLogger() factory function. SystemOutLogger: Writes log statements to STDOUT ( println ). Can be created using the systemOutLogger() factory function. By default, the AndroidLogger is used, but you can customize which ever one you want based on your needs. The Logger interface is very simple, and you can use it to create your custom implementations as well.","title":"Logging"},{"location":"components/logging/#enabledisable-logging","text":"You can enable or disable logging by setting Vector.enableLogging .","title":"Enable/Disable Logging"},{"location":"components/saved-state-vectorviewmodel/","text":"SavedState VectorViewModel \u00b6 A subclass of VectorViewModel which provides easier state persistence across process deaths, by providing access to a SavedStateHandle from ViewModel SavedState library in Android Jetpack. Making state persistable \u00b6 The easiest way to persist your UI state is to simply save the entire state object using the saved state handle. However, you state class needs to implementing Parcelable for this, which is a tedious and error prone process. Luckily, Kotlin comes with an Android Extension which helps use make our classes Parcelable with just a single annotation. import kotlinx.android.parcel.Parcelize @Parcelize data class UserState ( val userId : Long = - 1 , val user : User ? = null , val isUserPremium : Boolean = false ): Parcelable Make sure that you have turned on the experimental flag in your build.gradle file to be able to access this feature: androidExtensions { experimental = true } Persisting State \u00b6 The SavedStateVectorViewModel class has a setStateAndPersist method which is the same as the regular setState method, except that it also persists the new state. fun greetUser () = setStateAndPersist { copy ( greeting = \"Hello!\" ) } If you want to exclude some properties in your state object from being persisted, you must annotate them with @Transient . @Parcelize data class UserState ( val userId : Long = - 1 , @Transient val user : User ? = null , val isUserPremium : Boolean = false ): Parcelable This method by default tries to persist your entire state object using KEY_SAVED_STATE key defined in this class. If you need to customize this behaviour, you should override the persistState method. override fun persistState () = withState { state -> // Your custom implementation }","title":"SavedState VectorViewModel"},{"location":"components/saved-state-vectorviewmodel/#savedstate-vectorviewmodel","text":"A subclass of VectorViewModel which provides easier state persistence across process deaths, by providing access to a SavedStateHandle from ViewModel SavedState library in Android Jetpack.","title":"SavedState VectorViewModel"},{"location":"components/saved-state-vectorviewmodel/#making-state-persistable","text":"The easiest way to persist your UI state is to simply save the entire state object using the saved state handle. However, you state class needs to implementing Parcelable for this, which is a tedious and error prone process. Luckily, Kotlin comes with an Android Extension which helps use make our classes Parcelable with just a single annotation. import kotlinx.android.parcel.Parcelize @Parcelize data class UserState ( val userId : Long = - 1 , val user : User ? = null , val isUserPremium : Boolean = false ): Parcelable Make sure that you have turned on the experimental flag in your build.gradle file to be able to access this feature: androidExtensions { experimental = true }","title":"Making state persistable"},{"location":"components/saved-state-vectorviewmodel/#persisting-state","text":"The SavedStateVectorViewModel class has a setStateAndPersist method which is the same as the regular setState method, except that it also persists the new state. fun greetUser () = setStateAndPersist { copy ( greeting = \"Hello!\" ) } If you want to exclude some properties in your state object from being persisted, you must annotate them with @Transient . @Parcelize data class UserState ( val userId : Long = - 1 , @Transient val user : User ? = null , val isUserPremium : Boolean = false ): Parcelable This method by default tries to persist your entire state object using KEY_SAVED_STATE key defined in this class. If you need to customize this behaviour, you should override the persistState method. override fun persistState () = withState { state -> // Your custom implementation }","title":"Persisting State"},{"location":"components/vector-fragment/","text":"Vector Fragment \u00b6 Vector Fragment is an abstract class that extends the AndroidX Fragment class. You are not required to use it, the only benefit it offers is that it has convenient fragmentScope and viewScope Couroutine Scopes which can be used to easily launch Coroutines. VectorFragment class also has an abstract renderState(state: S, renderer: (S) -> Unit) method, which should be used by subclasses in their onViewCreated callback. It is supposed to be the place where Views update themselves. You are free to choose your own implementation and not extend from VectorFragment at all. An example of how the renderState function should look like: class UsersListFragment : VectorFragment () { private val viewModel : UserViewModel by viewModel () override fun onViewCreated (...) { renderState ( viewModel ) { state -> // Update your views here } } } The renderState method internally launches a coroutine in a Coroutine Scope scoped to fragment's view-lifecycle. Therefore it must be called in the onViewCreated method. Vector is not opinionated about what should be used as Views in an app, so please feel free to use whatever you like. However, the VectorViewModel class exposes the current state observable as a Kotlin Flow object, so it helps if your View object is a CoroutineScope .","title":"Vector Fragment"},{"location":"components/vector-fragment/#vector-fragment","text":"Vector Fragment is an abstract class that extends the AndroidX Fragment class. You are not required to use it, the only benefit it offers is that it has convenient fragmentScope and viewScope Couroutine Scopes which can be used to easily launch Coroutines. VectorFragment class also has an abstract renderState(state: S, renderer: (S) -> Unit) method, which should be used by subclasses in their onViewCreated callback. It is supposed to be the place where Views update themselves. You are free to choose your own implementation and not extend from VectorFragment at all. An example of how the renderState function should look like: class UsersListFragment : VectorFragment () { private val viewModel : UserViewModel by viewModel () override fun onViewCreated (...) { renderState ( viewModel ) { state -> // Update your views here } } } The renderState method internally launches a coroutine in a Coroutine Scope scoped to fragment's view-lifecycle. Therefore it must be called in the onViewCreated method. Vector is not opinionated about what should be used as Views in an app, so please feel free to use whatever you like. However, the VectorViewModel class exposes the current state observable as a Kotlin Flow object, so it helps if your View object is a CoroutineScope .","title":"Vector Fragment"},{"location":"components/vector-state/","text":"Vector State \u00b6 Vector recommends using immutable Kotlin Data Classes to represent your UI Model classes. Such classes should implement the VectorState interface, because the VectorViewModel class is generic on a subtype of this interface. It is recommended to keep your state classes immutable, otherwise you risk your UI model getting into inconsistent states when there are multiple sources producing state updates concurrently. Example \u00b6 data class ProfilePageState ( val user : User , val isLoading : Boolean , val isError : Boolean ): VectorState Using a Data Class provides the benefit of the automatically generated copy() method. It allows you to mutate the state very easily, you just need to provide the values that have actually changed, and the others will be kept the same. For example, if the User Profile page in the above example starts in the Loading state, the initial state model would look like this: val initialState = ProfilePageState ( user = cachedUser , isLoading = true , isError = false ) When the loading completes, the state can be mutated easily like this: val newState = initialState . copy ( user = userRetrievedFromNetwork , isLoading = false ) Since the isError variable value remains the same (false), we do not need to supply it in the copy method. Sealed Class based Model Classes \u00b6 A great way to represent all possible states a screen can be in is using Kotlin's Sealed Classes. Continuing the profile page example, suppose we want to show a different types of information based on whether the user is a premium user or not. We can do it this way: sealed class ProfilePageState : VectorState { data class PremiumProfilePage ( val user : User , val accountPerks : List < Perks >, val isLoading : Boolean , val isError : Boolean ): ProfilePageState () data class StandardProfilePage ( val user : User , val isLoading : Boolean , val isError : Boolean ): ProfilePageState () } This allows you to separate similar, but related states of a screen. It increases verbosity though, and you lose direct access to convenient data class methods, unless you type cast the state object into one of its subclasses. Persistable state \u00b6 Kotlin Extensions for Android have the ability to automatically generate Parcelable implementations of data classes with the @Parcelize annotation. This can be leveraged to easily persist state classes when needed. @Parcelize data class ProfilePageState ( ... ): Parcelable When needed, this state can be directly put as a Serializable into a SavedInstanceState bundle or a SavedStateHandle in a ViewModel. Automatic State Restoration \u00b6 If you use the lazy ViewModel delegates shipped with Vector, you must ensure that either: Your state class has default values for every property, or Your ViewModel class implements the VectorViewModelFactory interface along with its initialState method This is to ensure that we can create an instance of your state class automatically.","title":"Vector State"},{"location":"components/vector-state/#vector-state","text":"Vector recommends using immutable Kotlin Data Classes to represent your UI Model classes. Such classes should implement the VectorState interface, because the VectorViewModel class is generic on a subtype of this interface. It is recommended to keep your state classes immutable, otherwise you risk your UI model getting into inconsistent states when there are multiple sources producing state updates concurrently.","title":"Vector State"},{"location":"components/vector-state/#example","text":"data class ProfilePageState ( val user : User , val isLoading : Boolean , val isError : Boolean ): VectorState Using a Data Class provides the benefit of the automatically generated copy() method. It allows you to mutate the state very easily, you just need to provide the values that have actually changed, and the others will be kept the same. For example, if the User Profile page in the above example starts in the Loading state, the initial state model would look like this: val initialState = ProfilePageState ( user = cachedUser , isLoading = true , isError = false ) When the loading completes, the state can be mutated easily like this: val newState = initialState . copy ( user = userRetrievedFromNetwork , isLoading = false ) Since the isError variable value remains the same (false), we do not need to supply it in the copy method.","title":"Example"},{"location":"components/vector-state/#sealed-class-based-model-classes","text":"A great way to represent all possible states a screen can be in is using Kotlin's Sealed Classes. Continuing the profile page example, suppose we want to show a different types of information based on whether the user is a premium user or not. We can do it this way: sealed class ProfilePageState : VectorState { data class PremiumProfilePage ( val user : User , val accountPerks : List < Perks >, val isLoading : Boolean , val isError : Boolean ): ProfilePageState () data class StandardProfilePage ( val user : User , val isLoading : Boolean , val isError : Boolean ): ProfilePageState () } This allows you to separate similar, but related states of a screen. It increases verbosity though, and you lose direct access to convenient data class methods, unless you type cast the state object into one of its subclasses.","title":"Sealed Class based Model Classes"},{"location":"components/vector-state/#persistable-state","text":"Kotlin Extensions for Android have the ability to automatically generate Parcelable implementations of data classes with the @Parcelize annotation. This can be leveraged to easily persist state classes when needed. @Parcelize data class ProfilePageState ( ... ): Parcelable When needed, this state can be directly put as a Serializable into a SavedInstanceState bundle or a SavedStateHandle in a ViewModel.","title":"Persistable state"},{"location":"components/vector-state/#automatic-state-restoration","text":"If you use the lazy ViewModel delegates shipped with Vector, you must ensure that either: Your state class has default values for every property, or Your ViewModel class implements the VectorViewModelFactory interface along with its initialState method This is to ensure that we can create an instance of your state class automatically.","title":"Automatic State Restoration"},{"location":"components/vector-viewmodel/","text":"Vector ViewModel \u00b6 The VectorViewModel class is the place where the UI state is stored. It is also the only place which can perform changes to the UI state. You must extend this class in your own ViewModels. It is generic on a state class implementing the VectorState interface. data class UserState (...): VectorState class UserViewModel ( initialState : UsersState ): VectorViewModel < UsersState >( initialState ) { ... } Creating a ViewModel \u00b6 A ViewModel is scoped to the Lifecycle of its owning Fragment or Activity. An Activity can access Activity-scoped ViewModels, whereas Fragments can create both Fragment-scoped and Activity-scoped ViewModels. The library ships with a few Kotlin property delegates which make it easy to create a VectorViewModel for whichever scope you need. From a Fragment: val userViewModel : UserViewModel by fragmentViewModel () // Scoped to this fragment // OR val userViewModel : UserViewModel by activityViewModel () // Scoped to the parent activity From an Activity: val userViewModel : UserViewModel by viewModel () // Scoped to this activity These delegates automatically create the ViewModel for you, as long as they do not have any external dependencies. ViewModels with additional dependencies \u00b6 If your ViewModel has external dependencies, then you should use an alternative version of these delegates which accepts a trailing lambda that should contain the code to create your ViewModel. val userViewModel : UserViewModel by fragmentViewModel { initialState , savedStateHandle -> UserViewModel ( initialState , UserRepository ()) } Alternatively, you can choose to implement the VectorViewModelFactory interface in your ViewModel's companion object to provide your own implementation for its create and initialState methods. class UserViewModel ( initialState : UserState , val repository : UserRepository ) { ... companion object : VectorViewModelFactory < UserViewModel , UserState > { override fun initialState ( handle : SavedStateHandle , owner : ViewModelOwner ): UserState ? { // Create state object directly or restore it using `SavedStateHandle` } override fun create ( initialState : UserState , owner : ViewModelOwner , handle : SavedStateHandle ): UserViewModel ? { // Create and return your ViewModel // the `owner` parameter can be used to access your DI graph } } } Support for AssistedInject factories \u00b6 If you use Dagger and AssistedInject in your project, then you can create ViewModels in this way: @Inject val usersViewModelFactory : UsersViewModel . Factory // The AssistedInject factory val userViewModel : UserViewModel by fragmentViewModel { initialState , savedStateHandle -> userViewModelFactory . create ( initialState , ...) } Managing State \u00b6 Mutating State \u00b6 State mutation is done through the setState function, which accepts regular lambdas as well as suspending lambdas . The supplied lambda is given the current state as the receiver , and it is responsible for creating a new state and returning it. class UserViewModel (...): VectorViewModel < UserState >(...) { fun greetUser () = setState { val currentState = this // this = current state val newState = UsersState ( greeting = \"Hello!\" , user = currentState . user ) newState } } If the state class is a Kotlin Data class , then this can be expressed succintly as: fun greetUser () = setState { copy ( greeting = \"Hello!\" ) } This works because the this received in the setState block is the current state, which has a copy method define for it by virtue of being a data class. Note State mutations are processed asynchronously. You should not rely on the state to be updated immediately after you call the setState function. Every state mutation is enqueued to a Channel on a background thread, which processes them sequentially to avoid race conditions. Accessing State \u00b6 If you need to access the current state and perform some action based on it, you should use the withState function. It receives the current state as a parameter, and can then use it to perform decisions based on it. fun greetUser () = withState { state -> if ( state . isUserPremium ()) { setState { copy ( greeting = \"Hello, premium user!\" ) } } else { setState { copy ( greeting = \"Hello!\" )} } } withState blocks, just like setState blocks, are processed on a background thread asynchronously. The state parameter supplied to withState is guaranteed to be the latest state at the time of processing the lambda. Any nested setState blocks are processed immediately, before any other withState blocks can be processed. Warning While there are other ways to access the state in your ViewModel, using the withState function is the safest way to do so. Since state updates are processed asynchronously, other methods are not guaranteed to have the latest state when you access it. The withState block always receives the latest state as a parameter when it is processed. Note There's also a currentState property in a VectorViewModel , but it should not be used in place of a withState block. currentState only provides a convenient way for external classes to access the current state without subscribing to it. Observing state changes \u00b6 A VectorViewModel exposes state to fragments and activities through a Kotlin Flow . A Flow is a cold stream of values, which is active only while there is someone subscribing to it. You can subscribe to state changes like this: class UserActivity : AppCompatActivity () { private val userViewModel : UserViewModel by viewModel () private val coroutineScope = MainScope () override fun onCreate (...) { coroutineScope . launch { userViewModel . state . collect { state -> updateState ( state ) } } } fun updateState ( state : UserState ) { ... } override fun onDestroy (...) { coroutineScope . cancel () } } Example \u00b6 Here's an example of how to use the VectorViewModel: data class UserState ( val user : User ? = null , isError : Boolean = false , isLoading : Boolean = false ): VectorState class UserViewModel ( initState : UserState , private val repository : UserRepository ): VectorViewModel < UsersState >( initState ) { init { viewModelScope . launch { getUserDetails () } } private suspend fun getUserDetails () { setState { copy ( isLoading = true ) } val users = repository . getUser () if ( user == null ) { setState { copy ( user = null , isError = true , isLoading = false ) } } else { setState { copy ( usersList = users , isLoading = false ) } } } } class UserFragment : VectorFragment () { private val viewModel : UserViewModel by fragmentViewModel { initialState , savedStateHandle -> UserViewModel ( initialState , savedStateHandle ) } override fun onCreate (...) { renderState ( viewModel ) { state -> ... } } } Warning ViewModels only survive configuration changes such as screen rotations. They do NOT survive process death. State Persistence \u00b6 While ViewModels are great for storing UI state because they survive configuration changes, you still need to take care of persisting your UI state in the event of a process death. To make this process easier, the library ships with a specialized version of VectorViewModel , named the SavedStateVectorViewModel which leverages the ViewModel SavedState Module for state persistence.","title":"Vector ViewModel"},{"location":"components/vector-viewmodel/#vector-viewmodel","text":"The VectorViewModel class is the place where the UI state is stored. It is also the only place which can perform changes to the UI state. You must extend this class in your own ViewModels. It is generic on a state class implementing the VectorState interface. data class UserState (...): VectorState class UserViewModel ( initialState : UsersState ): VectorViewModel < UsersState >( initialState ) { ... }","title":"Vector ViewModel"},{"location":"components/vector-viewmodel/#creating-a-viewmodel","text":"A ViewModel is scoped to the Lifecycle of its owning Fragment or Activity. An Activity can access Activity-scoped ViewModels, whereas Fragments can create both Fragment-scoped and Activity-scoped ViewModels. The library ships with a few Kotlin property delegates which make it easy to create a VectorViewModel for whichever scope you need. From a Fragment: val userViewModel : UserViewModel by fragmentViewModel () // Scoped to this fragment // OR val userViewModel : UserViewModel by activityViewModel () // Scoped to the parent activity From an Activity: val userViewModel : UserViewModel by viewModel () // Scoped to this activity These delegates automatically create the ViewModel for you, as long as they do not have any external dependencies.","title":"Creating a ViewModel"},{"location":"components/vector-viewmodel/#viewmodels-with-additional-dependencies","text":"If your ViewModel has external dependencies, then you should use an alternative version of these delegates which accepts a trailing lambda that should contain the code to create your ViewModel. val userViewModel : UserViewModel by fragmentViewModel { initialState , savedStateHandle -> UserViewModel ( initialState , UserRepository ()) } Alternatively, you can choose to implement the VectorViewModelFactory interface in your ViewModel's companion object to provide your own implementation for its create and initialState methods. class UserViewModel ( initialState : UserState , val repository : UserRepository ) { ... companion object : VectorViewModelFactory < UserViewModel , UserState > { override fun initialState ( handle : SavedStateHandle , owner : ViewModelOwner ): UserState ? { // Create state object directly or restore it using `SavedStateHandle` } override fun create ( initialState : UserState , owner : ViewModelOwner , handle : SavedStateHandle ): UserViewModel ? { // Create and return your ViewModel // the `owner` parameter can be used to access your DI graph } } }","title":"ViewModels with additional dependencies"},{"location":"components/vector-viewmodel/#support-for-assistedinject-factories","text":"If you use Dagger and AssistedInject in your project, then you can create ViewModels in this way: @Inject val usersViewModelFactory : UsersViewModel . Factory // The AssistedInject factory val userViewModel : UserViewModel by fragmentViewModel { initialState , savedStateHandle -> userViewModelFactory . create ( initialState , ...) }","title":"Support for AssistedInject factories"},{"location":"components/vector-viewmodel/#managing-state","text":"","title":"Managing State"},{"location":"components/vector-viewmodel/#mutating-state","text":"State mutation is done through the setState function, which accepts regular lambdas as well as suspending lambdas . The supplied lambda is given the current state as the receiver , and it is responsible for creating a new state and returning it. class UserViewModel (...): VectorViewModel < UserState >(...) { fun greetUser () = setState { val currentState = this // this = current state val newState = UsersState ( greeting = \"Hello!\" , user = currentState . user ) newState } } If the state class is a Kotlin Data class , then this can be expressed succintly as: fun greetUser () = setState { copy ( greeting = \"Hello!\" ) } This works because the this received in the setState block is the current state, which has a copy method define for it by virtue of being a data class. Note State mutations are processed asynchronously. You should not rely on the state to be updated immediately after you call the setState function. Every state mutation is enqueued to a Channel on a background thread, which processes them sequentially to avoid race conditions.","title":"Mutating State"},{"location":"components/vector-viewmodel/#accessing-state","text":"If you need to access the current state and perform some action based on it, you should use the withState function. It receives the current state as a parameter, and can then use it to perform decisions based on it. fun greetUser () = withState { state -> if ( state . isUserPremium ()) { setState { copy ( greeting = \"Hello, premium user!\" ) } } else { setState { copy ( greeting = \"Hello!\" )} } } withState blocks, just like setState blocks, are processed on a background thread asynchronously. The state parameter supplied to withState is guaranteed to be the latest state at the time of processing the lambda. Any nested setState blocks are processed immediately, before any other withState blocks can be processed. Warning While there are other ways to access the state in your ViewModel, using the withState function is the safest way to do so. Since state updates are processed asynchronously, other methods are not guaranteed to have the latest state when you access it. The withState block always receives the latest state as a parameter when it is processed. Note There's also a currentState property in a VectorViewModel , but it should not be used in place of a withState block. currentState only provides a convenient way for external classes to access the current state without subscribing to it.","title":"Accessing State"},{"location":"components/vector-viewmodel/#observing-state-changes","text":"A VectorViewModel exposes state to fragments and activities through a Kotlin Flow . A Flow is a cold stream of values, which is active only while there is someone subscribing to it. You can subscribe to state changes like this: class UserActivity : AppCompatActivity () { private val userViewModel : UserViewModel by viewModel () private val coroutineScope = MainScope () override fun onCreate (...) { coroutineScope . launch { userViewModel . state . collect { state -> updateState ( state ) } } } fun updateState ( state : UserState ) { ... } override fun onDestroy (...) { coroutineScope . cancel () } }","title":"Observing state changes"},{"location":"components/vector-viewmodel/#example","text":"Here's an example of how to use the VectorViewModel: data class UserState ( val user : User ? = null , isError : Boolean = false , isLoading : Boolean = false ): VectorState class UserViewModel ( initState : UserState , private val repository : UserRepository ): VectorViewModel < UsersState >( initState ) { init { viewModelScope . launch { getUserDetails () } } private suspend fun getUserDetails () { setState { copy ( isLoading = true ) } val users = repository . getUser () if ( user == null ) { setState { copy ( user = null , isError = true , isLoading = false ) } } else { setState { copy ( usersList = users , isLoading = false ) } } } } class UserFragment : VectorFragment () { private val viewModel : UserViewModel by fragmentViewModel { initialState , savedStateHandle -> UserViewModel ( initialState , savedStateHandle ) } override fun onCreate (...) { renderState ( viewModel ) { state -> ... } } } Warning ViewModels only survive configuration changes such as screen rotations. They do NOT survive process death.","title":"Example"},{"location":"components/vector-viewmodel/#state-persistence","text":"While ViewModels are great for storing UI state because they survive configuration changes, you still need to take care of persisting your UI state in the event of a process death. To make this process easier, the library ships with a specialized version of VectorViewModel , named the SavedStateVectorViewModel which leverages the ViewModel SavedState Module for state persistence.","title":"State Persistence"},{"location":"misc/automatic-viewmodel-creation/","text":"Automatic ViewModel creation \u00b6 Vector ships with some lazy delegates for instantiating ViewModels automatically. val viewModel by fragmentViewModel () by activityViewModel () by viewModel () val viewModel by fragmentViewModel { initialState , savedStateHandle -> ... } by activityViewModel { initialState , savedStateHandle -> ... } by viewModel { initialState , savedStateHandle -> ... } These delegates use Reflection to instantiate your ViewModels. The process goes as follows: First, we try to create the initial state for your ViewModel using either the ViewModel factory or using the constructor. If the ViewModel implements VectorViewModelFactory in its companion object, we attempt to create initial state using it If the ViewModel does not implement that interface, or it does not override the initialState() method, then we attempt to create initial state using the state class constructor. For this to succeed, all properties in your state class must have default values. If both the strategies fail, we throw an exception and crash. Then, we try to create the ViewModel. If the delegate has been supplied a trailing lambda which tells us how to produce the ViewModel, we invoke it, register the ViewModel with the ViewModelProvider for the calling Activity/Fragment and return it. Otherwise, we check if the ViewModel implements VectorViewModelFactory in its companion object. If so, we attempt to create the ViewModel using its create method. If the ViewModel does not implement that interface or if the returned ViewModel is null, we try to create the ViewModel using its constructor. For this to succeed, the ViewModel must have one of the following constructors: ViewModel() ViewModel(initialState) ViewModel(initialState, savedStateHandle) ViewModel(initialState, stateStoreContext, savedStateHandle) If these conditions can not be met, we throw an exception and crash. Therefore, the ViewModel's VectorViewModelFactory is given priority for both tasks if it is implemented. Otherwise, we resort to constructor invocations.","title":"Automatic ViewModel Creation"},{"location":"misc/automatic-viewmodel-creation/#automatic-viewmodel-creation","text":"Vector ships with some lazy delegates for instantiating ViewModels automatically. val viewModel by fragmentViewModel () by activityViewModel () by viewModel () val viewModel by fragmentViewModel { initialState , savedStateHandle -> ... } by activityViewModel { initialState , savedStateHandle -> ... } by viewModel { initialState , savedStateHandle -> ... } These delegates use Reflection to instantiate your ViewModels. The process goes as follows: First, we try to create the initial state for your ViewModel using either the ViewModel factory or using the constructor. If the ViewModel implements VectorViewModelFactory in its companion object, we attempt to create initial state using it If the ViewModel does not implement that interface, or it does not override the initialState() method, then we attempt to create initial state using the state class constructor. For this to succeed, all properties in your state class must have default values. If both the strategies fail, we throw an exception and crash. Then, we try to create the ViewModel. If the delegate has been supplied a trailing lambda which tells us how to produce the ViewModel, we invoke it, register the ViewModel with the ViewModelProvider for the calling Activity/Fragment and return it. Otherwise, we check if the ViewModel implements VectorViewModelFactory in its companion object. If so, we attempt to create the ViewModel using its create method. If the ViewModel does not implement that interface or if the returned ViewModel is null, we try to create the ViewModel using its constructor. For this to succeed, the ViewModel must have one of the following constructors: ViewModel() ViewModel(initialState) ViewModel(initialState, savedStateHandle) ViewModel(initialState, stateStoreContext, savedStateHandle) If these conditions can not be met, we throw an exception and crash. Therefore, the ViewModel's VectorViewModelFactory is given priority for both tasks if it is implemented. Otherwise, we resort to constructor invocations.","title":"Automatic ViewModel creation"},{"location":"misc/state-store-context/","text":"Coroutine Context for the State Store \u00b6 Every VectorViewModel has a backing StateHolder and a StateStore . The StateHolder is responsible for holding the current state, and the StateStore is responsible for processing state access/mutation blocks. All state related actions are processed off the main thread, in a sequential manner using a Coroutine Actor. The coroutine context for this actor is by default defined as: Dispatchers.Default + Job() . If you wish to customize the state store coroutine context, you may do so by supplying your custom context in the ViewModel. abstract class VectorViewModel < S : VectorState >( initialState : S ?, stateStoreContext : CoroutineContext = Dispatchers . Default + Job (), // <- Change this parameter in your own implementations protected val logger : Logger = androidLogger () )","title":"Coroutine Context for State Store"},{"location":"misc/state-store-context/#coroutine-context-for-the-state-store","text":"Every VectorViewModel has a backing StateHolder and a StateStore . The StateHolder is responsible for holding the current state, and the StateStore is responsible for processing state access/mutation blocks. All state related actions are processed off the main thread, in a sequential manner using a Coroutine Actor. The coroutine context for this actor is by default defined as: Dispatchers.Default + Job() . If you wish to customize the state store coroutine context, you may do so by supplying your custom context in the ViewModel. abstract class VectorViewModel < S : VectorState >( initialState : S ?, stateStoreContext : CoroutineContext = Dispatchers . Default + Job (), // <- Change this parameter in your own implementations protected val logger : Logger = androidLogger () )","title":"Coroutine Context for the State Store"},{"location":"usage/advanced/","text":"Advanced Usage \u00b6 Let us continue with the example described in the Basics page. Dependency Injection support \u00b6 Our ViewModel needs access to a Repository or a Use-Case class in order to be able to fetch the user's notes. In the Usage section, we setup the repository as a singleton Kotlin object , so that we could access it without creating an instance of it. This is rarely the case in real applications, and it is much more common to split your business logic into different Use-Case classes. Let us create a GetNotesUseCase class for our notes app: class GetNotesUseCase ( private val repository : NotesRepository ) { fun getAllNotes () { ... } fun getPinnedNotes () { ... } fun getArchivedNotes () { ... } } Our ViewModel now looks like this: class NotesListViewModel ( initialState : NotesListState , private val notesUseCase : GetNotesUseCase ): VectorViewModel < NotesListState >( initialState ) { ... suspend fun getNotes () { ... } suspend fun getAllNotes () { val allNotes = notesUseCase . getAllNotes () setState { copy ( notes = allNotes ) } } suspend fun getPinnedNotes () { ... } suspend fun getArchivedNotes () { ... } } Due to the addition of an additional dependency in the constructor which Vector can not satisfy on its own , we can not instantiate this ViewModel in our Fragment or Activity in the way we did before. We need to tell Vector how to satisfy this ViewModel's dependencies using a VectorViewModelFactory , implemented in this ViewModel's companion object . The VectorViewModelFactory interface has a method named create() , which is used to create and return an instance of this ViewModel. The create() method is supplied with a ViewModelOwner parameter, which is a wrapper around the Fragment/Activity owning this ViewModel. It can be used to get access to your dependency injection library's object graph. You must not store a reference to this owner in your ViewModel, or you will create a memory leak for your Activity or Fragment. class NotesListViewModel ( initialState : NotesListState , private val notesUseCase : GetNotesUseCase ): VectorViewModel < NotesListState >( initialState ) { ... companion object : VectorViewModelFactory < NotesListViewModel , NotesListState > { fun create ( initialState : NotesListState , owner : ViewModelOwner , handle : SavedStateHandle ): NotesListViewModel ? { val usecase = // use the ViewModelOwner parameter to access DI graph and get GetNotesUseCase return NotesListViewmodel ( initialState , usecase ) } } } With this factory now implemented, we can get access to our ViewModel again using view model delegates such as by fragmentViewModel() . Vector will lookup the factory automatically, and use it to instantiate your ViewModel. Koin \u00b6 If you are using Koin , the create() method in a VectorViewModelFactory looks like this: fun create ( initialState : NotesListState , owner : ViewModelOwner , handle : SavedStateHandle ): NotesListViewModel ? { val usecase = when ( owner ) { is FragmentViewModelOwner -> owner . fragment . get < GetNotesUseCase >() // `get` extension method from Koin is ActivityViewModelOwner -> owner . activity . get < GetNotesUseCase >() } return NotesListViewmodel ( initialState , usecase ) } Dagger and AssistedInject \u00b6 Dagger can generate your DI graph at compile time, but it can not handle constructor paramters only available at run-time such as the initialState parameter in our ViewModel. The AssistedInject library helps with this, as it automatically generates factories for classes which depend on such runtime parameters. Usage of AssistedInject and Dagger in Vector looks like this: class NotesListViewModel @AssistedInject constructor ( @Assisted initialState : NotesListState , private val usecase : GetNotesUseCase ) { ... @AssistedInject . Factory interface Factory { fun create ( initialState : NotesListState ): NotesListViewModel } } class NotesListFragment : VectorFragment () { @Inject lateinit var viewModelFactory : NotesListViewModel . Factory private val viewModel : NotesListViewModel by fragmentViewModel { initialState , savedStateHandle -> viewModelFactory . create ( initialState ) } override fun onCreate (...) { inject () super . onCreate (...) } } We leverage another ViewModel delegate supplied by Vector which accepts a ViewModel producing lambda as an input. When this lambda is supplied, you don't need to implement the VectorViewModelFactory interface just to create your ViewModel with custom dependencies. Handling process death \u00b6 What's process death? \u00b6 When Android kills your application process while it is in the background, we call it process death. Before your application is killed, onSaveInstanceState is called for your Activities/Fragments, which can persist their state in a Bundle. When your application is recreated after a Process Death, you receive this bundle back as an argument as savedInstanceState in the onCreate() method. Doesn't a ViewModel handle this automatically? \u00b6 No, a ViewModel is built to handle configuration changes, such as rotations or locale changes. It does not survive process death. Any state held by the ViewModel is lost after a process death, and is not recoverable. The ViewModel is meant to handle state while in-memory, and the owning Fragment/Activity is supposed to save relevant parts of this state when being killed. You need to use both of these together to correctly handle state restoration . Problems with onSaveInstanceState \u00b6 This setup works okay-ish when your application is small, or when the state is not complex. The biggest problem with this setup is that it also makes the Activity or Fragment responsible for managing state. Besides, it is difficult to implement this method correctly, and the user must also remember to extract the saved state from the savedInstanceState bundle. Vector's solution \u00b6 The AndroidX ViewModel-SavedState library helps with this problem. Vector builds on this library and provides a SavedStateVectorViewModel , which uses the SavedStateHandle object to help with state persistence. class NotesListViewModel @AssistedInject constructor ( @Assisted initialState : NotesListState , @Assisted handle : SavedStateHandle , private val notesUse : GetNotesUseCase ): SavedStateVectorViewModel ( intitialState , savedStatehandle = handle ) The SavedStateVectorVieWModel has additional methods to help with state persistence: setStateAndPersist and persistState . To use them, we need to make sure that our state class implements the Parcelable interface. We can use the @Parcelize annotation from Kotlin-Android-Extensions to automatically generate the implementation for us. @Parcelize data class NotesListState (...): Parcelable Persisting state \u00b6 To persist state, we can simply replace the usage of setState in our ViewModel with setStateAndPersist to make sure that we save the latest state whenever it is modified. This way, whenever the application process is killed we would have already persisted the latest state. The setStateAndPersist method first invokes the state reducer, and then calls persistState() . The default implementation of persistState() simply takes the state object, and saves it to the SavedStateHandle using the key KEY_SAVED_SAVED defined in the companion object of SavedStateVectorViewModel . To customize this behaviour, you can override the persistState() method and provide your own implementation. Restoring state \u00b6 To restore the state, the initialState method of VectorViewModelFactory must be implemented in the ViewModel's companion object: fun initialState ( handle : SavedStateHandle , owner : ViewModelOwner ): NotesListState ? { val persistedState = handle [ KEY_SAVED_STATE ] if ( persistedState != null ) { return persistedState } else { ... } }","title":"Advanced Usage"},{"location":"usage/advanced/#advanced-usage","text":"Let us continue with the example described in the Basics page.","title":"Advanced Usage"},{"location":"usage/advanced/#dependency-injection-support","text":"Our ViewModel needs access to a Repository or a Use-Case class in order to be able to fetch the user's notes. In the Usage section, we setup the repository as a singleton Kotlin object , so that we could access it without creating an instance of it. This is rarely the case in real applications, and it is much more common to split your business logic into different Use-Case classes. Let us create a GetNotesUseCase class for our notes app: class GetNotesUseCase ( private val repository : NotesRepository ) { fun getAllNotes () { ... } fun getPinnedNotes () { ... } fun getArchivedNotes () { ... } } Our ViewModel now looks like this: class NotesListViewModel ( initialState : NotesListState , private val notesUseCase : GetNotesUseCase ): VectorViewModel < NotesListState >( initialState ) { ... suspend fun getNotes () { ... } suspend fun getAllNotes () { val allNotes = notesUseCase . getAllNotes () setState { copy ( notes = allNotes ) } } suspend fun getPinnedNotes () { ... } suspend fun getArchivedNotes () { ... } } Due to the addition of an additional dependency in the constructor which Vector can not satisfy on its own , we can not instantiate this ViewModel in our Fragment or Activity in the way we did before. We need to tell Vector how to satisfy this ViewModel's dependencies using a VectorViewModelFactory , implemented in this ViewModel's companion object . The VectorViewModelFactory interface has a method named create() , which is used to create and return an instance of this ViewModel. The create() method is supplied with a ViewModelOwner parameter, which is a wrapper around the Fragment/Activity owning this ViewModel. It can be used to get access to your dependency injection library's object graph. You must not store a reference to this owner in your ViewModel, or you will create a memory leak for your Activity or Fragment. class NotesListViewModel ( initialState : NotesListState , private val notesUseCase : GetNotesUseCase ): VectorViewModel < NotesListState >( initialState ) { ... companion object : VectorViewModelFactory < NotesListViewModel , NotesListState > { fun create ( initialState : NotesListState , owner : ViewModelOwner , handle : SavedStateHandle ): NotesListViewModel ? { val usecase = // use the ViewModelOwner parameter to access DI graph and get GetNotesUseCase return NotesListViewmodel ( initialState , usecase ) } } } With this factory now implemented, we can get access to our ViewModel again using view model delegates such as by fragmentViewModel() . Vector will lookup the factory automatically, and use it to instantiate your ViewModel.","title":"Dependency Injection support"},{"location":"usage/advanced/#koin","text":"If you are using Koin , the create() method in a VectorViewModelFactory looks like this: fun create ( initialState : NotesListState , owner : ViewModelOwner , handle : SavedStateHandle ): NotesListViewModel ? { val usecase = when ( owner ) { is FragmentViewModelOwner -> owner . fragment . get < GetNotesUseCase >() // `get` extension method from Koin is ActivityViewModelOwner -> owner . activity . get < GetNotesUseCase >() } return NotesListViewmodel ( initialState , usecase ) }","title":"Koin"},{"location":"usage/advanced/#dagger-and-assistedinject","text":"Dagger can generate your DI graph at compile time, but it can not handle constructor paramters only available at run-time such as the initialState parameter in our ViewModel. The AssistedInject library helps with this, as it automatically generates factories for classes which depend on such runtime parameters. Usage of AssistedInject and Dagger in Vector looks like this: class NotesListViewModel @AssistedInject constructor ( @Assisted initialState : NotesListState , private val usecase : GetNotesUseCase ) { ... @AssistedInject . Factory interface Factory { fun create ( initialState : NotesListState ): NotesListViewModel } } class NotesListFragment : VectorFragment () { @Inject lateinit var viewModelFactory : NotesListViewModel . Factory private val viewModel : NotesListViewModel by fragmentViewModel { initialState , savedStateHandle -> viewModelFactory . create ( initialState ) } override fun onCreate (...) { inject () super . onCreate (...) } } We leverage another ViewModel delegate supplied by Vector which accepts a ViewModel producing lambda as an input. When this lambda is supplied, you don't need to implement the VectorViewModelFactory interface just to create your ViewModel with custom dependencies.","title":"Dagger and AssistedInject"},{"location":"usage/advanced/#handling-process-death","text":"","title":"Handling process death"},{"location":"usage/advanced/#whats-process-death","text":"When Android kills your application process while it is in the background, we call it process death. Before your application is killed, onSaveInstanceState is called for your Activities/Fragments, which can persist their state in a Bundle. When your application is recreated after a Process Death, you receive this bundle back as an argument as savedInstanceState in the onCreate() method.","title":"What's process death?"},{"location":"usage/advanced/#doesnt-a-viewmodel-handle-this-automatically","text":"No, a ViewModel is built to handle configuration changes, such as rotations or locale changes. It does not survive process death. Any state held by the ViewModel is lost after a process death, and is not recoverable. The ViewModel is meant to handle state while in-memory, and the owning Fragment/Activity is supposed to save relevant parts of this state when being killed. You need to use both of these together to correctly handle state restoration .","title":"Doesn't a ViewModel handle this automatically?"},{"location":"usage/advanced/#problems-with-onsaveinstancestate","text":"This setup works okay-ish when your application is small, or when the state is not complex. The biggest problem with this setup is that it also makes the Activity or Fragment responsible for managing state. Besides, it is difficult to implement this method correctly, and the user must also remember to extract the saved state from the savedInstanceState bundle.","title":"Problems with onSaveInstanceState"},{"location":"usage/advanced/#vectors-solution","text":"The AndroidX ViewModel-SavedState library helps with this problem. Vector builds on this library and provides a SavedStateVectorViewModel , which uses the SavedStateHandle object to help with state persistence. class NotesListViewModel @AssistedInject constructor ( @Assisted initialState : NotesListState , @Assisted handle : SavedStateHandle , private val notesUse : GetNotesUseCase ): SavedStateVectorViewModel ( intitialState , savedStatehandle = handle ) The SavedStateVectorVieWModel has additional methods to help with state persistence: setStateAndPersist and persistState . To use them, we need to make sure that our state class implements the Parcelable interface. We can use the @Parcelize annotation from Kotlin-Android-Extensions to automatically generate the implementation for us. @Parcelize data class NotesListState (...): Parcelable","title":"Vector's solution"},{"location":"usage/advanced/#persisting-state","text":"To persist state, we can simply replace the usage of setState in our ViewModel with setStateAndPersist to make sure that we save the latest state whenever it is modified. This way, whenever the application process is killed we would have already persisted the latest state. The setStateAndPersist method first invokes the state reducer, and then calls persistState() . The default implementation of persistState() simply takes the state object, and saves it to the SavedStateHandle using the key KEY_SAVED_SAVED defined in the companion object of SavedStateVectorViewModel . To customize this behaviour, you can override the persistState() method and provide your own implementation.","title":"Persisting state"},{"location":"usage/advanced/#restoring-state","text":"To restore the state, the initialState method of VectorViewModelFactory must be implemented in the ViewModel's companion object: fun initialState ( handle : SavedStateHandle , owner : ViewModelOwner ): NotesListState ? { val persistedState = handle [ KEY_SAVED_STATE ] if ( persistedState != null ) { return persistedState } else { ... } }","title":"Restoring state"},{"location":"usage/basics/","text":"Basics \u00b6 To demonstrate the usage of Vector, let us build an imaginary note taking app. We are going to build the screen where we show all the notes saved by our user. A screen written using Vector typically has three components: A presenter, a state class, and a ViewModel. The State class \u00b6 The state class is a model for the UI state. It should have the following characteristics: Immutable, as the data in it could be accessed by multiple threads Contain all necessary data to render the UI Have default values for their properties. Our Notes screen at the very least needs a list of all the notes of our user. Additionally, let us also add the ability to filter the notes. Here's what the state class might look like: data class NotesListState ( val notes : List < Note > = listOf (), val filter : Filter = Filter . ALL ): VectorState enum class Filter { ALL , PINNED , ARCHIVED } Vector requires that you implement the VectorState interface in your state classes. It is an empty interface, and serves only as a marker for these classes. For an in-depth look at defining state, please read Vector State . The ViewModel class \u00b6 The ViewModel class serves as a holder for UI state, and also manages mutations/access to it. It survives configuration changes, and is tied to the logical lifecycle of a Fragment or Activity. Vector provides a VectorViewModel component for this. You should extend this class in your own ViewModels. Let's use it to build our NotesListViewModel . Initial State \u00b6 class NotesListViewModel ( initialState : NotesListState ): VectorViewModel < NotesListState >( initialState ) Our ViewModel has a dependency on an initialState object. Therefore, this ViewModel can not be handled directly with the ViewModelProviders class in the AndroidX Lifecycle library. We shall see how to get a hold of this ViewModel in the section on the presenter class . The initialState parameter represents the default state of UI. Our ViewModel needs this in order to be able to tell the presenter what to show the user when it first loads. Managing State \u00b6 A VectorViewModel exposes a Kotlin Flow of UI State to its owning Fragment/Activity. The owner can subscribe to this state flow, and render the UI according to whatever value is contained in it. From our ViewModel, whenever we produce a new state it should be pushed to this Flow, so that the UI can be informed that a new state has been created, and that it should re-render itself. When the ViewModel is first created, it sets the initialState object to the state flow. Our ViewModel is ready to get all the notes from our Repository, so let us fetch them as soon as the ViewModel is created. class NotesListViewModel ( initialState : NotesListState ): VectorViewModel < NotesListState >( initialState ) { init { viewModelScope . launch { getAllNotes () } } suspend fun getAllNotes () = withContext ( Dispatchers . IO ) { val notes = Repository . allNotes () ... } } Now that we have the notes, we are ready to show them to the user. How do we do this? By modifying the current state! Modifying/Mutating state \u00b6 We can modify the current state using the setState method, like this: suspend fun getAllNotes () = withContext ( Dispatchers . IO ) { val allNotes = Repository . allNotes () setState { // `this` = the current state copy ( notes = allNotes ) } } The setState method accepts a lambda which has the current state as the receiver. This lambda is often called as a \"Reducer\" . Since we used a data class to model our state, we have a copy() method on it generated automatically for us. We can use it to produce a new state from our current state. When the setState method is called, it enqueues its reducer to an internal queue. A coroutine processes the reducers in this queue sequentially on a background thread. Hence, state updates are performed asynchronously . When this reducer is processed, the new state object produced by it is pushed to the state flow to notify the UI that it should re-render itself. All of this happens automatically, and you do not need to worry about it. So when our setState block has finished processing, our UI will be notified that it should show this list of notes to our user! \ud83c\udf89\ud83c\udf89\ud83c\udf89 Warning Since state updates are processed asynchronously, you should not assume that you shall get the updated state immediately after the setState block. Accessing State \u00b6 Let us also add the ability to filter notes. We need to fetch notes based on what filter is set. To know what filter is currently set, we need access to the current state. The correct way to do this is to use the withState method. suspend fun getNotes () = withState { state -> when ( state . filter ) { ALL -> getAllNotes () PINNED -> getPinnedNotes () ARCHIVED -> getArchivedNotes () } } The withState block receives the current state as a parameter. We can use to take decisions which depend on the current state. withState , just like setState , is processed asynchronously. Our ViewModel now looks like this: class NotesListViewModel ( initialState : NotesListState ): VectorViewModel < NotesListState >( initialState ) { init { viewModelScope . launch { getNotes () } } suspend fun getNotes () = withState { state -> when ( state . filter ) { ALL -> getAllNotes () PINNED -> getPinnedNotes () ARCHIVED -> getArchivedNotes () } } suspend fun getAllNotes () { ... } suspend fun getPinnedNotes () { ... } suspend fun getArchivedNotes () { ... } } The Presenter class \u00b6 The presenter class serves as the UI for your application. Vector provides a simple VectorFragment component for this. It is a subclass of the AndroidX Fragment, and has a convenient CoroutineScope to launch coroutines. Let's use it to build our NotesListFragment class. class NotesListFragment : VectorFragment () Getting hold of the ViewModel \u00b6 Our Fragment needs access to its ViewModel. We usually use the ViewModelProviders class for this, but this will not work here , unless we create our own ViewModelProvider.Factory which knows how to create our ViewModel. Even then, the factory might not know how to create the initial state in more complex use cases. Vector provides some convenient lazy delegates to take care of this for you. From inside a fragment, we can request a ViewModel scoped to a fragment like this: class NotesListFragment : VectorFragment () { private val viewModel : NotesListViewModel by fragmentViewModel () } This will lazily instantiate the ViewModel for you! \ud83c\udf89\ud83c\udf89\ud83c\udf89 Note ViewModel delegates supplied by Vector can only create ViewModels with the same dependencies as the VectorViewModel class. If you have other dependencies in your ViewModel's constructor, please take a look at the \"ViewModels with additional dependencies\" section in the documentation for VectorViewModel . Observing state \u00b6 Now that we have our ViewModel, we can start observing state changes. To do this, we need to subscribe to the state flow exposed by the ViewModel. Subscribing to a Flow requires a Coroutine Scope, and luckily VectorFragment provides us with one. class NotesListFragment : VectorFragment () { private val viewModel : NotesListViewModel by fragmentViewModel () override fun onViewCreated () { ... viewScope . launch { viewModel . state . collect { state -> recyclerViewAdapter . submitList ( state . notes ) } } } } The viewScope property is a Coroutine Scope which is tied to the Fragment's view-lifecycle. This action of subscribing to state changes can be done more concisely using the renderState() method in the VectorFragment class. class NotesListFragment : VectorFragment () { private val viewModel : NotesListViewModel by fragmentViewModel () override fun onViewCreated () { ... renderState ( viewModel ) { state -> recyclerViewAdapter . submitList ( state . notes ) } } } Now whenever we get a new state object from our ViewModel, we automaticall update the user interface! \ud83c\udf89\ud83c\udf89\ud83c\udf89 Sending Actions to the ViewModel \u00b6 We have established how a ViewModel communicates with the presenter, but not how a presenter communicates with the ViewModel. In MVI-speak, presenter communicates with the ViewModel through Intents , or Actions . We are not referring to the android.content.Intent class here. Vector does not need you to define any classes which specify your Actions . A simpler way to communicate actions to the ViewModel is to simply call methods on it. Whenever the user changes their filter setting, we must notify our ViewModel. Let us add a method on our ViewModel to set a filter. class NotesListViewModel(...): VectorViewModel<NotesListState>(...) { fun changeFilter(newFilter: Filter) = setState { copy(filter = newFilter) getNotes() } } Now whenever the user sets a new filter, we fetch notes for it and update our state. The UI then re-renders according to the updated state. We have a working Notes list screen now! \ud83c\udf89\ud83c\udf89\ud83c\udf89 Advanced usage \u00b6 For more advanced use cases, such as dependency injection in a ViewModel, automatic state persistence across process deaths, customization of state store Coroutine Context, logging and more, please explore the relevant sections under the Component section in the navigation bar.","title":"Basics"},{"location":"usage/basics/#basics","text":"To demonstrate the usage of Vector, let us build an imaginary note taking app. We are going to build the screen where we show all the notes saved by our user. A screen written using Vector typically has three components: A presenter, a state class, and a ViewModel.","title":"Basics"},{"location":"usage/basics/#the-state-class","text":"The state class is a model for the UI state. It should have the following characteristics: Immutable, as the data in it could be accessed by multiple threads Contain all necessary data to render the UI Have default values for their properties. Our Notes screen at the very least needs a list of all the notes of our user. Additionally, let us also add the ability to filter the notes. Here's what the state class might look like: data class NotesListState ( val notes : List < Note > = listOf (), val filter : Filter = Filter . ALL ): VectorState enum class Filter { ALL , PINNED , ARCHIVED } Vector requires that you implement the VectorState interface in your state classes. It is an empty interface, and serves only as a marker for these classes. For an in-depth look at defining state, please read Vector State .","title":"The State class"},{"location":"usage/basics/#the-viewmodel-class","text":"The ViewModel class serves as a holder for UI state, and also manages mutations/access to it. It survives configuration changes, and is tied to the logical lifecycle of a Fragment or Activity. Vector provides a VectorViewModel component for this. You should extend this class in your own ViewModels. Let's use it to build our NotesListViewModel .","title":"The ViewModel class"},{"location":"usage/basics/#initial-state","text":"class NotesListViewModel ( initialState : NotesListState ): VectorViewModel < NotesListState >( initialState ) Our ViewModel has a dependency on an initialState object. Therefore, this ViewModel can not be handled directly with the ViewModelProviders class in the AndroidX Lifecycle library. We shall see how to get a hold of this ViewModel in the section on the presenter class . The initialState parameter represents the default state of UI. Our ViewModel needs this in order to be able to tell the presenter what to show the user when it first loads.","title":"Initial State"},{"location":"usage/basics/#managing-state","text":"A VectorViewModel exposes a Kotlin Flow of UI State to its owning Fragment/Activity. The owner can subscribe to this state flow, and render the UI according to whatever value is contained in it. From our ViewModel, whenever we produce a new state it should be pushed to this Flow, so that the UI can be informed that a new state has been created, and that it should re-render itself. When the ViewModel is first created, it sets the initialState object to the state flow. Our ViewModel is ready to get all the notes from our Repository, so let us fetch them as soon as the ViewModel is created. class NotesListViewModel ( initialState : NotesListState ): VectorViewModel < NotesListState >( initialState ) { init { viewModelScope . launch { getAllNotes () } } suspend fun getAllNotes () = withContext ( Dispatchers . IO ) { val notes = Repository . allNotes () ... } } Now that we have the notes, we are ready to show them to the user. How do we do this? By modifying the current state!","title":"Managing State"},{"location":"usage/basics/#modifyingmutating-state","text":"We can modify the current state using the setState method, like this: suspend fun getAllNotes () = withContext ( Dispatchers . IO ) { val allNotes = Repository . allNotes () setState { // `this` = the current state copy ( notes = allNotes ) } } The setState method accepts a lambda which has the current state as the receiver. This lambda is often called as a \"Reducer\" . Since we used a data class to model our state, we have a copy() method on it generated automatically for us. We can use it to produce a new state from our current state. When the setState method is called, it enqueues its reducer to an internal queue. A coroutine processes the reducers in this queue sequentially on a background thread. Hence, state updates are performed asynchronously . When this reducer is processed, the new state object produced by it is pushed to the state flow to notify the UI that it should re-render itself. All of this happens automatically, and you do not need to worry about it. So when our setState block has finished processing, our UI will be notified that it should show this list of notes to our user! \ud83c\udf89\ud83c\udf89\ud83c\udf89 Warning Since state updates are processed asynchronously, you should not assume that you shall get the updated state immediately after the setState block.","title":"Modifying/Mutating state"},{"location":"usage/basics/#accessing-state","text":"Let us also add the ability to filter notes. We need to fetch notes based on what filter is set. To know what filter is currently set, we need access to the current state. The correct way to do this is to use the withState method. suspend fun getNotes () = withState { state -> when ( state . filter ) { ALL -> getAllNotes () PINNED -> getPinnedNotes () ARCHIVED -> getArchivedNotes () } } The withState block receives the current state as a parameter. We can use to take decisions which depend on the current state. withState , just like setState , is processed asynchronously. Our ViewModel now looks like this: class NotesListViewModel ( initialState : NotesListState ): VectorViewModel < NotesListState >( initialState ) { init { viewModelScope . launch { getNotes () } } suspend fun getNotes () = withState { state -> when ( state . filter ) { ALL -> getAllNotes () PINNED -> getPinnedNotes () ARCHIVED -> getArchivedNotes () } } suspend fun getAllNotes () { ... } suspend fun getPinnedNotes () { ... } suspend fun getArchivedNotes () { ... } }","title":"Accessing State"},{"location":"usage/basics/#the-presenter-class","text":"The presenter class serves as the UI for your application. Vector provides a simple VectorFragment component for this. It is a subclass of the AndroidX Fragment, and has a convenient CoroutineScope to launch coroutines. Let's use it to build our NotesListFragment class. class NotesListFragment : VectorFragment ()","title":"The Presenter class"},{"location":"usage/basics/#getting-hold-of-the-viewmodel","text":"Our Fragment needs access to its ViewModel. We usually use the ViewModelProviders class for this, but this will not work here , unless we create our own ViewModelProvider.Factory which knows how to create our ViewModel. Even then, the factory might not know how to create the initial state in more complex use cases. Vector provides some convenient lazy delegates to take care of this for you. From inside a fragment, we can request a ViewModel scoped to a fragment like this: class NotesListFragment : VectorFragment () { private val viewModel : NotesListViewModel by fragmentViewModel () } This will lazily instantiate the ViewModel for you! \ud83c\udf89\ud83c\udf89\ud83c\udf89 Note ViewModel delegates supplied by Vector can only create ViewModels with the same dependencies as the VectorViewModel class. If you have other dependencies in your ViewModel's constructor, please take a look at the \"ViewModels with additional dependencies\" section in the documentation for VectorViewModel .","title":"Getting hold of the ViewModel"},{"location":"usage/basics/#observing-state","text":"Now that we have our ViewModel, we can start observing state changes. To do this, we need to subscribe to the state flow exposed by the ViewModel. Subscribing to a Flow requires a Coroutine Scope, and luckily VectorFragment provides us with one. class NotesListFragment : VectorFragment () { private val viewModel : NotesListViewModel by fragmentViewModel () override fun onViewCreated () { ... viewScope . launch { viewModel . state . collect { state -> recyclerViewAdapter . submitList ( state . notes ) } } } } The viewScope property is a Coroutine Scope which is tied to the Fragment's view-lifecycle. This action of subscribing to state changes can be done more concisely using the renderState() method in the VectorFragment class. class NotesListFragment : VectorFragment () { private val viewModel : NotesListViewModel by fragmentViewModel () override fun onViewCreated () { ... renderState ( viewModel ) { state -> recyclerViewAdapter . submitList ( state . notes ) } } } Now whenever we get a new state object from our ViewModel, we automaticall update the user interface! \ud83c\udf89\ud83c\udf89\ud83c\udf89","title":"Observing state"},{"location":"usage/basics/#sending-actions-to-the-viewmodel","text":"We have established how a ViewModel communicates with the presenter, but not how a presenter communicates with the ViewModel. In MVI-speak, presenter communicates with the ViewModel through Intents , or Actions . We are not referring to the android.content.Intent class here. Vector does not need you to define any classes which specify your Actions . A simpler way to communicate actions to the ViewModel is to simply call methods on it. Whenever the user changes their filter setting, we must notify our ViewModel. Let us add a method on our ViewModel to set a filter. class NotesListViewModel(...): VectorViewModel<NotesListState>(...) { fun changeFilter(newFilter: Filter) = setState { copy(filter = newFilter) getNotes() } } Now whenever the user sets a new filter, we fetch notes for it and update our state. The UI then re-renders according to the updated state. We have a working Notes list screen now! \ud83c\udf89\ud83c\udf89\ud83c\udf89","title":"Sending Actions to the ViewModel"},{"location":"usage/basics/#advanced-usage","text":"For more advanced use cases, such as dependency injection in a ViewModel, automatic state persistence across process deaths, customization of state store Coroutine Context, logging and more, please explore the relevant sections under the Component section in the navigation bar.","title":"Advanced usage"}]}